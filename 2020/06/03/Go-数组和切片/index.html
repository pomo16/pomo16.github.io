<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Go 数组、字符串和切片 | Atlantis</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go 数组、字符串和切片</h1><a id="logo" href="/.">Atlantis</a><p class="description">pomo16的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/toolbox/"><i class="fa fa-book"> 工具箱</i></a><a href="/community/"><i class="fa fa-comments"> 常用社区</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Go 数组、字符串和切片</h1><div class="post-meta">Jun 3, 2020<span> | </span><span class="category"><a href="/categories/go/">go</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 5.3k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 21</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="keyword">int</span>                    <span class="comment">// 定义长度为3的int型数组, 元素全部为0</span></span><br><span class="line"><span class="keyword">var</span> b = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;       <span class="comment">// 定义长度为3的int型数组, 元素为 1, 2, 3</span></span><br><span class="line"><span class="keyword">var</span> c = [...]<span class="keyword">int</span>&#123;<span class="number">2</span>: <span class="number">3</span>, <span class="number">1</span>: <span class="number">2</span>&#125;    <span class="comment">// 定义长度为3的int型数组, 元素为 0, 2, 3</span></span><br><span class="line"><span class="keyword">var</span> d = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>: <span class="number">5</span>, <span class="number">6</span>&#125; <span class="comment">// 定义长度为6的int型数组, 元素为 1, 2, 0, 0, 5, 6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>方式a：长度确定，数组中每个元素都以零值初始化</li>
<li>方式b：顺序指定全部元素的初始化值，数组的长度根据元素个数自动计算</li>
<li>方式c：以索引的方式来指定数组初始化元素，数组长度为最大指定索引，没有明确值的元素用零值初始化</li>
<li>方式d：混合了方式b和方式c</li>
</ul>
<h4 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h4><p>Go 中数组是值语义，一个数组变量就是整个数组，并不是隐式的指向第一个元素的指针（C语言）。所以当数组变量被赋值或者被传递的时候，实际上会复制整个数组。大数组会造成大的开销，为了避免复制数组带来的开销，可以传递一个指向数组的指针，但是数组指针并不是数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// a 是一个数组</span></span><br><span class="line"><span class="keyword">var</span> b = &amp;a                <span class="comment">// b 是指向数组的指针</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a[<span class="number">0</span>], a[<span class="number">1</span>])   <span class="comment">// 打印数组的前2个元素</span></span><br><span class="line">fmt.Println(b[<span class="number">0</span>], b[<span class="number">1</span>])   <span class="comment">// 通过数组指针访问数组元素的方式和数组类似</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> b &#123;     <span class="comment">// 通过数组指针迭代数组的元素</span></span><br><span class="line">    fmt.Println(i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是数组指针类型依然不够灵活，因为数组的长度是数组类型的组成部分，指向不同长度数组的数组指针类型也是完全不同的。<strong>可以将数组看作一个特殊的结构体，结构的字段名对应数组的索引，同时结构体成员的数目是固定的。</strong>内置函数 <code>len</code> 返回数组长度，<code>cap</code> 返回数组容量。不过对于数组来说，这两个的返回结果是一样的。</p>
<p>我们还可以用 for 循环来遍历数组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> a &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"a[%d]: %d\n"</span>, i, a[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> b &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"b[%d]: %d\n"</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(c); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"c[%d]: %d\n"</span>, i, c[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for range</code> 的性能会好一些，因为这种迭代保证不会出现数组越界的情况，每轮迭代对数组元素的访问可以省去对下标越界的判断。另外 <code>for range</code> 可以忽略迭代时的下标：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> times [<span class="number">5</span>][<span class="number">0</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> times &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述使用中，尽管数组第一维有长度，但是 <code>[0]int</code> 大小是0，因此整个数组占用内存大小依然是0。没有额外的内存代价，我们就通过 <code>for range</code> 实现了 <code>times</code> 次快速迭代。</p>
<h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>除了数值型数组，还可以定义字符串数组、结构体数组、函数数组、接口数组、管道数组等等。另外还有不常用的空数组，因为一般我们更倾向于去使用空结构体来用于管道同步。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是一个<strong>不可改变</strong>的字节序列，和数组不同，字符串的元素不可修改，是一个只读的字节数组，且长度固定。由于 Go 的源代码要求 UTF8 编码，导致 Go 源代码中出现的字符串字面量常量一般也是 UTF8 编码（对于转义字符，则没有这个限制）。源代码中的文本字符串通常被解释为采用 UTF8 编码的 Unicode 码点（rune）序列。字符串是只读的字节序列，可以包含包括byte值0的任意数据。我们也可以用字符串表示 GBK 等非 UTF8 编码的数据，但此时字符串可以看做是一个只读的二进制数组，因为 <code>for range</code> 等语法并不能支持非 UTF8 编码的字符串的遍历。</p>
<p>Go 语言字符串的底层结构在 <code>reflect.StringHeader</code> 中定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="keyword">uintptr</span></span><br><span class="line">    Len  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串结构包括了字符串指向的底层数组和字符串的字节长度。字符串其实就是一个结构体，因此字符串的赋值操作也就是 <code>reflect.StringHeader</code> 结构体的复制过程，并不会涉及底层字节数组的复制。<code>[2]string</code> 字符串数组对应的底层结构和 <code>[2]reflect.StringHeader</code> 对应的底层结构是一样的，可以将字符串数组看作一个结构体数组。举例来说 “Hello, world” 字符串底层数据和以下数组是完全一致的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [...]<span class="keyword">byte</span>&#123;</span><br><span class="line">    <span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">','</span>, <span class="string">' '</span>, <span class="string">'w'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'l'</span>, <span class="string">'d'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串虽然不是切片，但是支持切片操作，不同位置的切片底层也访问的同一块内存数据（因为字符串是只读的，相同的字符串面值常量通常是对应同一个字符串常量）:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hello, world"</span></span><br><span class="line">hello := s[:<span class="number">5</span>]</span><br><span class="line">world := s[<span class="number">7</span>:]</span><br><span class="line"></span><br><span class="line">s1 := <span class="string">"hello, world"</span>[:<span class="number">5</span>]</span><br><span class="line">s2 := <span class="string">"hello, world"</span>[<span class="number">7</span>:]</span><br></pre></td></tr></table></figure>
<p>字符串和数组类似，内置的<code>len</code>函数返回字符串的长度。或通过 <code>reflect.StringHeader</code> 结构访问字符串的长度（不推荐）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(s)</span><br><span class="line">fmt.Println(<span class="string">"len(s):"</span>, (*reflect.StringHeader)(unsafe.Pointer(&amp;s)).Len)</span><br></pre></td></tr></table></figure>
<p>提到 Go 字符串时，我们一般都会假设字符串对应的是一个合法的 UTF8 编码的字符序列。可以用内置的 <code>print</code> 调试函数或 <code>fmt.Print</code> 函数直接打印，也可以用 <code>for range</code> 循环直接遍历 UTF8 解码后的 Unicode 码点值。我们也可以在字符串面值中直指定UTF8编码后的值（源文件中全部是ASCII码，可以避免出现多字节的字符）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"\xe4\xb8\x96"</span>) <span class="comment">// 打印: 世</span></span><br><span class="line">fmt.Println(<span class="string">"\xe7\x95\x8c"</span>) <span class="comment">// 打印: 界</span></span><br></pre></td></tr></table></figure>
<p>Go 语言的字符串中可以存放任意的二进制字节序列，而且即使是 UTF8 字符序列也可能会遇到坏的编码。如果遇到一个错误的 UTF8 编码输入，将生成一个特别的 Unicode 字符 ‘\uFFFD’，通常显示为 ‘�’ 。错误编码不会向后扩散是 UTF8 编码的优秀特性之一：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"\xe4\x00\x00\xe7\x95\x8cabc"</span>) <span class="comment">// �界abc</span></span><br></pre></td></tr></table></figure>
<p>不过在 <code>for range</code> 迭代这个含有损坏的UTF8字符串时，第一字符的第二和第三字节依然会被单独迭代到，此时迭代的值是损坏后的0：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> <span class="string">"\xe4\x00\x00\xe7\x95\x8cabc"</span> &#123;</span><br><span class="line">    fmt.Println(i, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 65533  // \uFFFD, 对应 �</span></span><br><span class="line"><span class="comment">// 1 0      // 空字符</span></span><br><span class="line"><span class="comment">// 2 0      // 空字符</span></span><br><span class="line"><span class="comment">// 3 30028  // 界</span></span><br><span class="line"><span class="comment">// 6 97     // a</span></span><br><span class="line"><span class="comment">// 7 98     // b</span></span><br><span class="line"><span class="comment">// 8 99     // c</span></span><br></pre></td></tr></table></figure>
<p>Go 语言除了 <code>for range</code> 语法对 UTF8 字符串提供了特殊支持外，还对字符串和 <code>[]rune</code> 类型的相互转换提供了特殊的支持。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, []<span class="keyword">rune</span>(<span class="string">"世界"</span>))              <span class="comment">// []int32&#123;19990, 30028&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, <span class="keyword">string</span>([]<span class="keyword">rune</span>&#123;<span class="string">'世'</span>, <span class="string">'界'</span>&#125;))  <span class="comment">// 世界</span></span><br></pre></td></tr></table></figure>
<p>上面可以看出 <code>rune</code> 只是 <code>int32</code> 的别名，用于表示每个 Unicode 码点，目前只使用了21个 bit 位。</p>
<p>字符串的强制类型转换涉及 <code>[]byte</code> 和 <code>[]rune</code> 两种类型。在将字符串转为 <code>[]byte</code> 时，如果转换后的变量并没有被修改的情形，编译器可能会直接返回原始的字符串对应的底层数据。而在将字符串转为 <code>[]rune</code> 时，由于字符串底层的 <code>[]byte</code> 和 <code>[]int32</code> 类型的内部布局完全不同，所以这种转换可能隐含重新分配内存的操作（重构字符串），最差的情况是时间复杂度达到 O(n)。</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片简单来说就是一种简化版的动态数组，实际使用中，切片比数组的使用范围广泛很多。下面是切片的结构定义，<code>reflect.SliceHeader</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="keyword">uintptr</span></span><br><span class="line">    Len  <span class="keyword">int</span></span><br><span class="line">    Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切片的开头部分和 Go 字符串是一样的，但是切片多了一个 <code>Cap</code> 成员表示切片指向的内存空间的最大容量（对应元素的个数，而不是字节数）。和数组一样，内置的 <code>len</code> 函数返回切片中有效元素的长度，内置的 <code>cap</code> 函数返回切片容量大小，<strong>容量必须大于或等于切片的长度</strong>。切片可以和 <code>nil</code> 进行比较，<strong>只有当切片底层数据指针为空时切片本身为 <code>nil</code></strong>，这时候切片的长度和容量信息将是无效的。如果有切片的底层数据指针为空，但是长度和容量不为0的情况，那么说明切片本身已经被损坏了（比如直接通过 <code>reflect.SliceHeader</code> 或 <code>unsafe</code> 包对切片作了不正确的修改）。</p>
<p>切片的定义方式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a []<span class="keyword">int</span>               <span class="comment">// nil切片, 和 nil 相等, 一般用来表示一个不存在的切片</span></span><br><span class="line">    b = []<span class="keyword">int</span>&#123;&#125;           <span class="comment">// 空切片, 和 nil 不相等, 一般用来表示一个空的集合</span></span><br><span class="line">    c = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;    <span class="comment">// 有3个元素的切片, len和cap都为3</span></span><br><span class="line">    d = c[:<span class="number">2</span>]             <span class="comment">// 有2个元素的切片, len为2, cap为3</span></span><br><span class="line">    e = c[<span class="number">0</span>:<span class="number">2</span>:<span class="built_in">cap</span>(c)]     <span class="comment">// 有2个元素的切片, len为2, cap为3</span></span><br><span class="line">    f = c[:<span class="number">0</span>]             <span class="comment">// 有0个元素的切片, len为0, cap为3</span></span><br><span class="line">    g = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)    <span class="comment">// 有3个元素的切片, len和cap都为3</span></span><br><span class="line">    h = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 有2个元素的切片, len为2, cap为3</span></span><br><span class="line">    i = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">3</span>) <span class="comment">// 有0个元素的切片, len为0, cap为3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>切片的遍历、读取和修改都和数组一致。在对切片本身赋值或参数传递时，和数组指针的操作方式类似，只是复制切片头信息（<code>reflect.SliceHeader</code>），并不会复制底层的数据。<strong>对于类型，和数组的最大不同是，切片的类型和长度信息无关，只要是相同类型元素构成的切片均对应相同的切片类型。</strong></p>
<p>如前所说，切片是一种简化版的动态数组，这是切片类型的灵魂。除了构造切片和遍历切片之外，添加切片元素、删除切片元素都是切片处理中经常遇到的问题。</p>
<h4 id="添加切片元素"><a href="#添加切片元素" class="headerlink" title="添加切片元素"></a>添加切片元素</h4><p>内置的泛型函数 <code>append</code> 可以在切片的尾部追加 <code>N</code> 个元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>)               <span class="comment">// 追加1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)         <span class="comment">// 追加多个元素, 手写解包方式</span></span><br><span class="line">a = <span class="built_in">append</span>(a, []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;...) <span class="comment">// 追加一个切片, 切片需要解包</span></span><br></pre></td></tr></table></figure>
<p>不过要注意的是，在容量不足的情况下，<code>append</code> 的操作会导致重新分配内存，可能导致巨大的内存分配和复制数据代价。即使容量足够，依然需要用 <code>append</code> 函数的返回值来更新切片本身，因为新切片的长度已经发生了变化。</p>
<p>除了在切片的尾部追加，我们还可以在切片的开头添加元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">a = <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">0</span>&#125;, a...)        <span class="comment">// 在开头添加1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">-1</span>&#125;, a...) <span class="comment">// 在开头添加1个切片</span></span><br></pre></td></tr></table></figure>
<p>在开头一般都会导致内存的重新分配，而且会导致已有的元素全部复制1次。因此，从切片的开头添加元素的性能一般要比从尾部追加元素的性能差很多。</p>
<p>由于 <code>append</code> 函数返回新的切片，也就是它支持链式操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;x&#125;, a[i:]...)...)     <span class="comment">// 在第i个位置插入x</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, a[i:]...)...) <span class="comment">// 在第i个位置插入切片</span></span><br></pre></td></tr></table></figure>
<p>或者用 <code>copy</code> 和 <code>append</code> 组合可以避免创建中间的临时切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在第i个位置添加一个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">0</span>)     <span class="comment">// 切片扩展1个空间</span></span><br><span class="line"><span class="built_in">copy</span>(a[i+<span class="number">1</span>:], a[i:]) <span class="comment">// a[i:]向后移动1个位置</span></span><br><span class="line">a[i] = x             <span class="comment">// 设置新添加的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置添加多个元素(切片)</span></span><br><span class="line">a = <span class="built_in">append</span>(a, x...)       <span class="comment">// 为x切片扩展足够的空间</span></span><br><span class="line"><span class="built_in">copy</span>(a[i+<span class="built_in">len</span>(x):], a[i:]) <span class="comment">// a[i:]向后移动len(x)个位置</span></span><br><span class="line"><span class="built_in">copy</span>(a[i:], x)            <span class="comment">// 复制新添加的切片</span></span><br></pre></td></tr></table></figure>
<p>人为扩容属于副作用，有违切片本身的设计思想。</p>
<h4 id="删除切片元素"><a href="#删除切片元素" class="headerlink" title="删除切片元素"></a>删除切片元素</h4><p>删除尾部元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">a = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]   <span class="comment">// 删除尾部1个元素</span></span><br><span class="line">a = a[:<span class="built_in">len</span>(a)-N]   <span class="comment">// 删除尾部N个元素</span></span><br></pre></td></tr></table></figure>
<p>删除头部元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移动指针</span></span><br><span class="line">a = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">a = a[<span class="number">1</span>:] <span class="comment">// 删除开头1个元素</span></span><br><span class="line">a = a[N:] <span class="comment">// 删除开头N个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不移动指针原地完成</span></span><br><span class="line">a = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">0</span>], a[<span class="number">1</span>:]...) <span class="comment">// 删除开头1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">0</span>], a[N:]...) <span class="comment">// 删除开头N个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用copy删除开头</span></span><br><span class="line">a = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">a = a[:<span class="built_in">copy</span>(a, a[<span class="number">1</span>:])] <span class="comment">// 删除开头1个元素</span></span><br><span class="line">a = a[:<span class="built_in">copy</span>(a, a[N:])] <span class="comment">// 删除开头N个元素</span></span><br></pre></td></tr></table></figure>
<p>删除中间元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用copy和append组合原地完成</span></span><br><span class="line">a = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...&#125;</span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+<span class="number">1</span>:]...) <span class="comment">// 删除中间1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+N:]...) <span class="comment">// 删除中间N个元素</span></span><br><span class="line">a = a[:i+<span class="built_in">copy</span>(a[i:], a[i+<span class="number">1</span>:])]  <span class="comment">// 删除中间1个元素</span></span><br><span class="line">a = a[:i+<span class="built_in">copy</span>(a[i:], a[i+N:])]  <span class="comment">// 删除中间N个元素</span></span><br></pre></td></tr></table></figure>
<p>删除开头的元素和删除尾部的元素都可以认为是删除中间元素操作的特殊情况。</p>
<h4 id="切片内存技巧"><a href="#切片内存技巧" class="headerlink" title="切片内存技巧"></a>切片内存技巧</h4><p>对于切片来说， <code>len</code> 为0但是 <code>cap</code> 容量不为<code>0</code>的切片则是非常有用的特性。当然，如果 <code>len</code> 和 <code>cap</code> 都为 0 的话，则变成一个真正的空切片，虽然它并不是一个 <code>nil</code> 值的切片。<strong>在判断一个切片是否为空时，一般通过 <code>len</code> 获取切片的长度来判断，一般很少将切片和 <code>nil</code> 值做直接的比较。</strong></p>
<p>0长切片特性使用案例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除[]byte中的空格</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSpace</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="comment">//len为0但是cap为s的长度，删除操作中append肯定不会超出cap</span></span><br><span class="line">    b := s[:<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> x != <span class="string">' '</span> &#123;</span><br><span class="line">            b = <span class="built_in">append</span>(b, x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普适到所有过滤删除需求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Filter</span><span class="params">(s []<span class="keyword">byte</span>, fn <span class="keyword">func</span>(x <span class="keyword">byte</span>)</span> <span class="title">bool</span>) []<span class="title">byte</span></span> &#123;</span><br><span class="line">    b := s[:<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> !fn(x) &#123;</span><br><span class="line">            b = <span class="built_in">append</span>(b, x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切片高效操作的要点是要降低内存分配的次数，尽量保证 <code>append</code> 操作不会超出 <code>cap</code> 的容量，降低触发内存分配的次数和每次分配内存大小。</p>
<h4 id="避免切片内存泄露"><a href="#避免切片内存泄露" class="headerlink" title="避免切片内存泄露"></a>避免切片内存泄露</h4><p>如前面所说，切片操作并不会复制底层的数据。底层的数组会被保存在内存中，直到它不再被引用。但是有时候可能会因为一个小的内存引用而导致底层整个数组处于被使用的状态，这会延迟自动内存回收器对底层数组的回收。</p>
<p>例如，<code>FindPhoneNumber</code> 函数加载整个文件到内存，然后搜索第一个出现的电话号码，最后结果以切片方式返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindPhoneNumber</span><span class="params">(filename <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    b, _ := ioutil.ReadFile(filename)</span><br><span class="line">    <span class="keyword">return</span> regexp.MustCompile(<span class="string">"[0-9]+"</span>).Find(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码返回的 <code>[]byte</code> 指向保存整个文件的数组。因为切片引用了整个原始数组，导致自动垃圾回收器不能及时释放底层数组的空间。一个小的需求可能导致需要长时间保存整个文件数据。这虽然这并不是传统意义上的内存泄漏，但是可能会拖慢系统的整体性能。</p>
<p>要修复这个问题，可以将感兴趣的数据复制到一个新的切片中（<strong>数据的传值是Go语言编程的一个哲学，虽然传值有一定的代价，但是换取的好处是切断了对原始数据的依赖</strong>）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindPhoneNumber</span><span class="params">(filename <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    b, _ := ioutil.ReadFile(filename)</span><br><span class="line">    b = regexp.MustCompile(<span class="string">"[0-9]+"</span>).Find(b)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>([]<span class="keyword">byte</span>&#123;&#125;, b...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的问题，在删除切片元素时可能会遇到。假设切片里存放的是指针对象，那么下面删除末尾的元素后，被删除的元素依然被切片底层数组引用，从而导致不能及时被自动垃圾回收器回收（这要依赖回收器的实现方式）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []*<span class="keyword">int</span>&#123; ... &#125;</span><br><span class="line">a = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]    <span class="comment">// 被删除的最后一个元素依然被引用, 可能导致GC操作被阻碍</span></span><br></pre></td></tr></table></figure>
<p>保险的方式是先将需要自动内存回收的元素设置为 <code>nil</code>，保证自动回收器可以发现需要回收的对象，然后再进行切片的删除操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []*<span class="keyword">int</span>&#123; ... &#125;</span><br><span class="line">a[<span class="built_in">len</span>(a)<span class="number">-1</span>] = <span class="literal">nil</span> <span class="comment">// GC回收最后一个元素内存</span></span><br><span class="line">a = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]  <span class="comment">// 从切片删除最后一个元素</span></span><br></pre></td></tr></table></figure>
<p>当然，如果切片本身生命周期短的话完全不需要这样，等待整个切片被 GC 回收即可。</p>
<h4 id="切片强制类型转换"><a href="#切片强制类型转换" class="headerlink" title="切片强制类型转换"></a>切片强制类型转换</h4><p>为了安全，当两个切片类型 <code>[]T</code> 和 <code>[]Y</code> 的底层原始切片类型不同时，Go语言是无法直接转换类型的。但是有时候转换有简化编码或者提升性能的价值，比如在64位系统上，需要对一个 <code>[]float64</code> 切片进行高速排序，我们可以将它强制转为 <code>[]int</code> 整数切片，然后以整数的方式进行排序（因为 <code>float64</code> 遵循 IEEE754 浮点数标准特性，当浮点数有序时对应的整数也必然是有序的）。下面的代码通过两种方法将 <code>[]float64</code> 类型的切片转换为 <code>[]int</code> 类型的切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build amd64 arm64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sort"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = []<span class="keyword">float64</span>&#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">88</span>, <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SortFloat64FastV1</span><span class="params">(a []<span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 强制类型转换</span></span><br><span class="line">    <span class="keyword">var</span> b []<span class="keyword">int</span> = ((*[<span class="number">1</span> &lt;&lt; <span class="number">20</span>]<span class="keyword">int</span>)(unsafe.Pointer(&amp;a[<span class="number">0</span>])))[:<span class="built_in">len</span>(a):<span class="built_in">cap</span>(a)]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以int方式给float64排序</span></span><br><span class="line">    sort.Ints(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SortFloat64FastV2</span><span class="params">(a []<span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通过 reflect.SliceHeader 更新切片头部信息实现转换</span></span><br><span class="line">    <span class="keyword">var</span> c []<span class="keyword">int</span></span><br><span class="line">    aHdr := (*reflect.SliceHeader)(unsafe.Pointer(&amp;a))</span><br><span class="line">    cHdr := (*reflect.SliceHeader)(unsafe.Pointer(&amp;c))</span><br><span class="line">    *cHdr = *aHdr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以int方式给float64排序</span></span><br><span class="line">    sort.Ints(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种强制转换是先将切片数据的开始地址转换为一个较大的数组的指针，然后对数组指针对应的数组重新做切片操作。中间需要 <code>unsafe.Pointer</code> 来连接两个不同类型的指针传递。需要注意的是，Go 语言实现中非0大小数组的长度不得超过2GB，因此需要针对数组元素的类型大小计算数组的最大长度范围（<code>[]uint8</code> 最大2GB，<code>[]uint16</code> 最大1GB，以此类推，但是 <code>[]struct{}</code> 数组的长度可以超过2GB）。</p>
<p>第二种转换操作是分别取到两个不同类型的切片头信息指针，任何类型的切片头部信息底层都是对应 <code>reflect.SliceHeader</code> 结构，然后通过更新结构体方式来更新切片信息，从而实现 <code>a</code> 对应的 <code>[]float64</code> 切片到 <code>c</code> 对应的 <code>[]int</code> 类型切片的转换。</p>
<p>不过需要注意的是，这个方法可行的前提是要保证 <code>[]float64</code> 中没有 NaN 和 Inf 等非规范的浮点数（因为浮点数中 NaN 不可排序，正0和负0相等，但是整数中没有这类情形）。</p>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h4 id="数组和切片在传参上的差异"><a href="#数组和切片在传参上的差异" class="headerlink" title="数组和切片在传参上的差异"></a>数组和切片在传参上的差异</h4><p>直接看例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"%v\n"</span>, arr)</span><br><span class="line"></span><br><span class="line">	slice := []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"%v\n"</span>, slice)</span><br><span class="line"></span><br><span class="line">	changeArrayItem(arr)</span><br><span class="line">	changeSliceItem(slice)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"%v\n"</span>, arr)</span><br><span class="line">	fmt.Printf(<span class="string">"%v\n"</span>, slice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeArrayItem</span><span class="params">(base [3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	base[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSliceItem</span><span class="params">(base []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	base[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//output</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">[<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line">[<span class="number">10</span> <span class="number">4</span> <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>可以看出数组是值传递，切片是引用传递，而且数组形参在定义时必须准确定义长度。</p>
<p>切片在传参上还有一个坑，就是 <code>append</code> 操作造成的引用丢失：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice := []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"before: %v\n"</span>, slice)</span><br><span class="line"></span><br><span class="line">	appendSliceItem(slice)</span><br><span class="line">	fmt.Printf(<span class="string">"after: %v\n"</span>, slice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendSliceItem</span><span class="params">(slice []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	slice = <span class="built_in">append</span>(slice, <span class="number">100</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"func: %v\n"</span>, slice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//output</span></span><br><span class="line">before: [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span>: [3 4 5 100]</span></span><br><span class="line"><span class="function"><span class="title">after</span>: [3 4 5]</span></span><br></pre></td></tr></table></figure>
<p>由于 <code>append</code> 返回的是一个新的切片引用，因此在函数内的添加变更只体现在新切片引用上。除非函数返回新的切片引用，否则原上下文无法让旧引用重新赋值为新切片的引用。要解决这个问题除了直接用函数返回值更新外，还可以用引用的引用来解决：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice := []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"before: %v\n"</span>, slice)</span><br><span class="line"></span><br><span class="line">	appendSliceItem(&amp;slice)</span><br><span class="line">	fmt.Printf(<span class="string">"after: %v\n"</span>, slice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendSliceItem</span><span class="params">(slice *[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	*slice = <span class="built_in">append</span>(*slice, <span class="number">100</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"func: %v\n"</span>, *slice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//output</span></span><br><span class="line">before: [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span>: [3 4 5 100]</span></span><br><span class="line"><span class="function"><span class="title">after</span>: [3 4 5 100]</span></span><br></pre></td></tr></table></figure>
<p>下面用一个递归例子在展示两种方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursiveTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr1 := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	insertTo10(&amp;arr1)</span><br><span class="line">	fmt.Println(arr1)</span><br><span class="line"></span><br><span class="line">	arr2 := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	arr2 = insertTo10V2(arr2)</span><br><span class="line">	fmt.Println(arr2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertTo10</span><span class="params">(arr *[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(*arr)</span><br><span class="line">	<span class="keyword">if</span> length == <span class="number">10</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	*arr = <span class="built_in">append</span>(*arr, length)</span><br><span class="line">	insertTo10(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertTo10V2</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="keyword">if</span> length == <span class="number">10</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> arr</span><br><span class="line">	&#125;</span><br><span class="line">	arr = <span class="built_in">append</span>(arr, length)</span><br><span class="line">	<span class="keyword">return</span> insertTo10V2(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//output</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/go/">go</a></div><div class="post-nav"><a class="pre" href="/2020/06/05/Docker安装ES及IK分词器/">Docker安装ES相关</a><a class="next" href="/2020/06/02/Go-struct-类型Channel/">Go struct{}类型Channel</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ElasticSearch/">ElasticSearch</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/blog/">blog</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/data/">data</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">19</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/Redis/">Redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/jsp/">jsp</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/jsp/Servlet/">Servlet</a><span class="category-list-count">1</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/projects/">projects</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/web/docker/">docker</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/微信小程序/">微信小程序</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/ElasticSearch/" style="font-size: 15px;">ElasticSearch</a> <a href="/tags/Eclipse/" style="font-size: 15px;">Eclipse</a> <a href="/tags/go/" style="font-size: 15px;">go</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/rpc/" style="font-size: 15px;">rpc</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/JavaWeb/" style="font-size: 15px;">JavaWeb</a> <a href="/tags/jsp/" style="font-size: 15px;">jsp</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/七牛云/" style="font-size: 15px;">七牛云</a> <a href="/tags/CDN/" style="font-size: 15px;">CDN</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a> <a href="/tags/RSS/" style="font-size: 15px;">RSS</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/ftp/" style="font-size: 15px;">ftp</a> <a href="/tags/jre/" style="font-size: 15px;">jre</a> <a href="/tags/jdk/" style="font-size: 15px;">jdk</a> <a href="/tags/projects/" style="font-size: 15px;">projects</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/tags/Servlet/" style="font-size: 15px;">Servlet</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/hive/" style="font-size: 15px;">hive</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/集合/" style="font-size: 15px;">集合</a> <a href="/tags/操作系统/" style="font-size: 15px;">操作系统</a> <a href="/tags/数组/" style="font-size: 15px;">数组</a> <a href="/tags/String/" style="font-size: 15px;">String</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/03/04/Python-Garbage-Collection/">Python Garbage Collection</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/15/Hive/">Hive</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/15/Hadoop核心组件/">Hadoop核心组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/05/Docker安装ES及IK分词器/">Docker安装ES相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/03/Go-数组和切片/">Go 数组、字符串和切片</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/02/Go-struct-类型Channel/">Go struct{}类型Channel</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/16/Concurrency-in-Go/">Concurrency in Go</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/22/Docker搭建FTP/">Docker搭建FTP</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/Go-Garbage-Collection/">Go Garbage Collection</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/20/git/">git</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/pomo16" title="我的Github" target="_blank">我的Github</a><ul></ul><a href="https://blog.csdn.net/pomo16" title="我的CSDN" target="_blank">我的CSDN</a><ul></ul><a href="http://pomo16.coding.me/" title="我的老博客(荒废已久)" target="_blank">我的老博客(荒废已久)</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">Atlantis.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script><!-- 添加点击爱心功能--><script type="text/javascript" src="/js/clicklove.js?v=0.0.0"></script></div></body></html>