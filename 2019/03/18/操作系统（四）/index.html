<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>操作系统（四） | Atlantis</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">操作系统（四）</h1><a id="logo" href="/.">Atlantis</a><p class="description">pomo16的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/toolbox/"><i class="fa fa-book"> 工具箱</i></a><a href="/community/"><i class="fa fa-comments"> 常用社区</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">操作系统（四）</h1><div class="post-meta">Mar 18, 2019<span> | </span><span class="category"><a href="/categories/操作系统/">操作系统</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 4k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 14</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li>定义<ul>
<li>进程是指一个具有一定<strong>独立功能</strong>的程序在一个<strong>数据集合</strong>上的一次动态执行过程</li>
</ul>
</li>
<li>进程的组成<ul>
<li>进程包含了正在运行的一个程序的<strong>所有状态</strong>信息<ul>
<li>代码</li>
<li>数据</li>
<li>状态寄存器：CPU 状态 CR0 、指令指针 IP</li>
<li>通用寄存器：AX、BX、CX…</li>
<li>进程占用系统资源：打开文件、已分配内存…</li>
</ul>
</li>
<li><img src="http://qnya.pomo16.club/54.png" alt></li>
</ul>
</li>
<li>进程的特点<ul>
<li>动态性：可动态地创建，结束进程</li>
<li>并发性：进程可以被独立调度并占用处理机运行</li>
<li>独立性：不同进程的工作不相互影响</li>
<li>制约性：因访问共享数据/资源或进程间同步而产生制约<br><img src="http://qnya.pomo16.club/55.png" alt></li>
</ul>
</li>
<li>进程与程序的联系<ul>
<li>进程是操作系统处于执行状态程序的抽象<ul>
<li>程序 = 文件 (静态的可执行文件)</li>
<li>进程 = 执行中的程序 = 程序 + 执行状态</li>
</ul>
</li>
<li>同一个程序的多次执行过程对应为不同进程<ul>
<li>如命令 “ ls “ 的多次执行对应多个进程</li>
</ul>
</li>
<li>进程执行需要的资源<ul>
<li>内存：保存代码和数据</li>
<li>CPU：执行指令</li>
</ul>
</li>
</ul>
</li>
<li>进程与程序的区别<ul>
<li>进程是动态的，程序是静态的<ul>
<li>程序是有序代码的集合</li>
<li>进程是程序的执行，进程有核心态/用户态</li>
</ul>
</li>
<li>进程是暂时的，程序的永久的<ul>
<li>进程是一个状态变化的过程</li>
<li>程序可长久保存</li>
</ul>
</li>
<li>进程与程序的组成不同<ul>
<li>进程的组成包括程序、数据和进程控制块</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程控制块-PCB，Process-Control-Block"><a href="#进程控制块-PCB，Process-Control-Block" class="headerlink" title="进程控制块( PCB，Process Control Block )"></a>进程控制块( PCB，Process Control Block )</h3><ul>
<li>定义：操作系统管理控制进程运行所用的信息集合<ul>
<li>操作系统用 PCB 来描述进程的基本情况以及运行变化的过程</li>
<li>PCB 是进程存在的唯一标志<ul>
<li>每个进程都在操作系统中有一个对应的 PCB</li>
</ul>
</li>
<li>进程控制块的使用<ul>
<li>进程创建：生成该进程的 PCB</li>
<li>进程终止：回收它的 PCB</li>
<li>进程的组织管理：通过对 PCB 的组织管理来实现</li>
</ul>
</li>
</ul>
</li>
<li>进程控制块内容<ul>
<li>进程标识信息</li>
<li>处理机现场保存</li>
<li>进程控制信息<ul>
<li>调度和状态信息：进程和处理机制使用情况调度</li>
<li>进程间通信信息：进程间通信相关的各种标识</li>
<li>存储管理信息：指向进程映像存储空间数据结构</li>
<li>进程所用资源：进程使用的系统资源，如打开文件等</li>
<li>有关数据结构连接信息：与 PCB 相关的进程队列</li>
</ul>
</li>
</ul>
</li>
<li>进程控制块的组织<ul>
<li>链表：同一状态的进程其 PCB 成一链表，多个状态对应多个不同的链表<ul>
<li>各状态的进程形成不同的链表：就绪链表、阻塞链表</li>
</ul>
</li>
<li>索引表：同一状态的进程归入一个索引表(由索引指向 PCB )，多个状态对应多个不同的索引表<ul>
<li>各状态的进程形成不同的索引表：就绪索引表、阻塞索引表</li>
</ul>
</li>
<li><img src="http://qnya.pomo16.club/56.png" alt></li>
</ul>
</li>
</ul>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul>
<li>进程的生命周期划分<ul>
<li>进程创建<ul>
<li>引起进程创建的情况<ul>
<li>系统初始化时</li>
<li>用户请求创建一个新进程</li>
<li>正在运行的进程执行了创建进程的系统调用</li>
</ul>
</li>
</ul>
</li>
<li>进程执行<ul>
<li>内核选择一个就绪的进程，让它占用处理机并执行</li>
</ul>
</li>
<li>进程等待<ul>
<li>进入等待(阻塞)的情况<ul>
<li>请求并等待系统服务，无法马上完成</li>
<li>启动某种操作，无法马上完成</li>
<li>需要的数据没有到达</li>
</ul>
</li>
<li>只有进程自身才能知道何时需要等待某种事件的发生</li>
</ul>
</li>
<li>进程抢占<ul>
<li>进程会被抢占的情况<ul>
<li>高优先级进程就绪</li>
<li>进程执行当前时间用完</li>
</ul>
</li>
</ul>
</li>
<li>进程唤醒<ul>
<li>唤醒进程的情况<ul>
<li>被阻塞进程需要的资源可被满足</li>
<li>被阻塞进程等待的事件到达</li>
</ul>
</li>
<li>进程只能被别的进程或者操作系统唤醒</li>
</ul>
</li>
<li>进程结束<ul>
<li>进程结束的情况<ul>
<li>正常退出(自愿的)</li>
<li>错误退出(自愿的)</li>
<li>致命错误(强制性的)</li>
<li>被其他进程扼杀(强制性的)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="三状态进程模型"><a href="#三状态进程模型" class="headerlink" title="三状态进程模型"></a>三状态进程模型</h3><ul>
<li>三个主要状态<ul>
<li>运行状态( Running )：进程正在处理机上运行</li>
<li>就绪状态( Ready )：进程获得了除处理机之外的所需资源，得到处理机即可运行</li>
<li>等待状态( 又称阻塞状态 Blocked )：进程正在等待某一事件的出现而暂停运行</li>
</ul>
</li>
<li>辅助状态<ul>
<li>创建状态( New )：一个进程正在被创建，还没被转到就绪状态之前的状态</li>
<li>结束状态( Exit )：一个进程正在从系统中消失时的状态，这是因为进程结束或由于其他原因所导致</li>
</ul>
</li>
<li>状态变迁<ul>
<li>NULL &gt; 创建：一个新进程被产生出来执行一个程序</li>
<li>创建 &gt; 就绪：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态</li>
<li>就绪 &gt; 运行：处于就绪状态的进程被进程调度程序选中后，就分配到处理机上来运行</li>
<li>运行 &gt; 结束：当进程表示它已经完成或者因出错，当前运行进程会由操作系统作结束处理</li>
<li>运行 &gt; 就绪：处于运行状态的进程在其运行过程中，由于分配给它的处理机时间片用完而让出处理机</li>
<li>运行 &gt; 等待：当进程请求某资源且必须等待时</li>
<li>等待 &gt; 就绪：当进程要等待某事件到来时，它从阻塞状态变到就绪状态</li>
</ul>
</li>
<li><img src="http://qnya.pomo16.club/57.png" alt></li>
</ul>
<h3 id="挂起进程模型"><a href="#挂起进程模型" class="headerlink" title="挂起进程模型"></a>挂起进程模型</h3><ul>
<li>进程挂起：处于挂起状态的进程映像在磁盘上，目的是减少进程占用内存</li>
<li>新增状态<ul>
<li>等待挂起状态( Blocked-suspend )：进程在外存并等待某事件的出现</li>
<li>就绪挂起状态( Ready-suspend )：进程在外存，但只要进入内存即可运行</li>
</ul>
</li>
<li>新增状态变迁<ul>
<li>挂起( Suspend )：把一个进程从内存转到外存<ul>
<li>等待到等待挂起：没有进程处于就绪状态或就绪进程要求更多内存资源</li>
<li>就绪到就绪挂起：当有高优先级等待(系统认为会很快就绪的)进程和低优先级就绪进程</li>
<li>运行到就绪挂起：对抢先式分时系统，当有高优先级等待挂起进程因事件出现而进入就绪挂起</li>
</ul>
</li>
<li>在外存时的状态转换<ul>
<li>等待挂起到就绪挂起：当有等待挂起进程因相关事件出现</li>
</ul>
</li>
<li>激活( Activate )：把一个进程从外存转到内存<ul>
<li>就绪挂起到就绪：没有就绪进程或挂起就绪进程优先级高于就绪进程</li>
<li>等待挂起到等待：当一个进程释放足够内存，并有高优先级等待挂起进程</li>
</ul>
</li>
</ul>
</li>
<li>状态队列<ul>
<li>由操作系统来维护一组队列，表示系统中所有进程的当前状态</li>
<li>不同队列表示不同状态<ul>
<li>就绪队列、各种等待队列</li>
</ul>
</li>
<li>根据进程状态不同，进程 PCB 加入相应队列<ul>
<li>进程状态变化时，它所在的 PCB 会从一个队列换到另一个</li>
</ul>
</li>
</ul>
</li>
<li><img src="http://qnya.pomo16.club/58.png" alt></li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li>定义：线程是进程的一部分，描述指令流执行状态。它是进程中的<strong>指令执行流</strong>的最小单元，是 CPU <strong>调度</strong>的基本单位<ul>
<li>进程的资源分配角色：进程由一组相关资源构成，包括地址空间(代码段、数据段)、打开的文件等各种资源</li>
<li>线程的处理机调度角色：线程描述在进程资源环境中的指令流执行状态</li>
<li><img src="http://qnya.pomo16.club/59.png" alt></li>
</ul>
</li>
<li>进程和线程的关系<br><img src="http://qnya.pomo16.club/60.png" alt></li>
<li>线程 = 进程 - 共享资源<ul>
<li>线程的优点<ul>
<li>一个进程中可以同时存入多个线程</li>
<li>各个线程之间可以并发地执行</li>
<li>各个线程之间可以共享地址空间和文件等资源</li>
</ul>
</li>
<li>线程的缺点<ul>
<li>一个线程崩溃，会导致其所属进程的所有线程崩溃</li>
</ul>
</li>
</ul>
</li>
<li>线程和进程的比较<ul>
<li>进程是资源分配单位，线程是 CPU 调度单位</li>
<li>进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源，如寄存器和栈</li>
<li>线程具有就绪、等待和运行三种基本状态和状态间的转换关系</li>
<li>线程能减少并发执行的时间和空间开销<ul>
<li>线程的创建时间比进程短</li>
<li>线程的终止时间比进程短</li>
<li>同一进程内的线程切换时间比进程短</li>
<li>由于同一进程的各线程间共享内存和文件资源，可不通过内核进行直接通信</li>
</ul>
</li>
</ul>
</li>
<li>线程的三种实现方式<ul>
<li>用户线程：在用户空间实现<ul>
<li>POSIX Pthreads，Mach C-threads，Solaris threads</li>
</ul>
</li>
<li>内核线程：在内核中实现<ul>
<li>Windows，Solaris，Linux</li>
</ul>
</li>
<li>轻量级进程：在内核中实现，支持用户线程<ul>
<li>Solaris ( LightWeight Process )</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h3><ul>
<li>定义：由一组用户级的线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等<br><img src="http://qnya.pomo16.club/61.png" alt></li>
<li>特征<ul>
<li>不依赖于操作系统的内核<ul>
<li>内核不了解用户线程的存在</li>
<li>可用于不支持线程的多进程操作系统</li>
</ul>
</li>
<li>在用户空间实现的线程机制<ul>
<li>每个进程有私有的线程控制块( TCB )列表</li>
<li>TCB 有线程库函数维护</li>
</ul>
</li>
<li>同一进程内的用户线程切换速度快<ul>
<li>无需用户态/内核态切换</li>
</ul>
</li>
<li>允许每个进程拥有自己的线程调度算法</li>
</ul>
</li>
<li>不足<ul>
<li>线程发起系统调用而阻塞时，则整个进程进入等待</li>
<li>不支持基于线程的处理机抢占<ul>
<li>除非当前运行线程主动放弃，它所在进程的其他线程无法抢占 CPU</li>
</ul>
</li>
<li>只能按进程分配 CPU 时间<ul>
<li>多个线程进程中，每个线程的时间片较少</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><ul>
<li>定义：由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止和管理<br><img src="http://qnya.pomo16.club/62.png" alt></li>
<li>特征<ul>
<li>由内核维护 PCB 和 TCB</li>
<li>线程执行系统调用而被阻塞不影响其他线程</li>
<li>线程的创建、终止和切换相对较大<ul>
<li>通过系统调用/内核函数，在内核实现</li>
</ul>
</li>
<li>以线程为单位进行 CPU 时间分配<ul>
<li>多线程的进程可获得更多 CPU 时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="轻权进程-LightWeight-Process"><a href="#轻权进程-LightWeight-Process" class="headerlink" title="轻权进程( LightWeight Process )"></a>轻权进程( LightWeight Process )</h3><p>内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个轻权进程由一个单独的内核线程来支持。(Solaris/Linux)<br><img src="http://qnya.pomo16.club/63.png" alt></p>
<h3 id="用户进程与内核线程的对应关系"><a href="#用户进程与内核线程的对应关系" class="headerlink" title="用户进程与内核线程的对应关系"></a>用户进程与内核线程的对应关系</h3><p><img src="http://qnya.pomo16.club/64.png" alt></p>
<ul>
<li>实际实现中，一对一效果最好</li>
</ul>
<p>#进程管理 </p>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><ul>
<li>进程切换(上下文切换)<ul>
<li>暂停当前运行进程，从运行状态变为其他状态</li>
<li>调度另一个进程从就绪状态变成运行状态</li>
</ul>
</li>
<li>进程切换的要求<ul>
<li>切换前，保存进程上下文</li>
<li>切换后，恢复进程上下文</li>
<li>快速切换</li>
</ul>
</li>
<li>进程生命周期的信息<ul>
<li>寄存器( PC，SP，…)</li>
<li>CPU 状态</li>
<li>内存地址空间</li>
</ul>
</li>
<li>上下文切换图示<br><img src="http://qnya.pomo16.club/65.png" alt></li>
<li>进程控制块 PCB ：内核的进程状态记录<ul>
<li>内核为每个进程维护了对应的进程控制块 ( PCB )</li>
<li>内核将相同状态的进程的 PCB 放置在同一队列<ul>
<li>就绪队列</li>
<li>I/O 等待队列<ul>
<li>每个设备一个队列</li>
</ul>
</li>
<li>僵尸队列<br><img src="http://qnya.pomo16.club/66.png" alt></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><ul>
<li><p>创建新进程</p>
<ul>
<li>Windows 进程创建 API：CreateProcess(filename)<ul>
<li>创建时关闭所有在子进程里的文件描述符<ul>
<li>CreateProcess(filename, CLOSE_FD)</li>
</ul>
</li>
<li>创建时改变子进程的环境<ul>
<li>CreateProcess(filename, CLOSE_FD, new_envp)</li>
</ul>
</li>
<li>等等</li>
</ul>
</li>
<li><p>Unix 进程创建系统调用：fork/exec</p>
<ul>
<li>fork() 把一个进程复制成两个进程<ul>
<li>parent (old PID)，child (new PID)</li>
</ul>
</li>
<li>exec() 用新程序来重写当前进程<ul>
<li>PID 没有改变</li>
</ul>
</li>
<li><p>用 fork 和 exec 创建进程的示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pid = fork();				<span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="comment">//Do anything (unmap memory, close net connections...)</span></span><br><span class="line">  exec(<span class="string">"program"</span>,argc,argv0,argv1,...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>fork() 创建一个继承的子进程</p>
<ul>
<li>复制父进程的所有变量和内存</li>
<li>复制父进程的所有 CPU 寄存器(有一个寄存器例外)</li>
</ul>
</li>
<li>fork() 的返回值<ul>
<li>子进程的 fork() 返回0</li>
<li>父进程的 fork() 返回子进程标识符</li>
<li>fork() 返回值可方便后续使用，子进程可使用 getpid() 获取 PID</li>
</ul>
</li>
<li>fork() 的地址空间复制<ul>
<li>fork() 执行过程对于子进程而言，是在调用时间对父进程地址空间的一次复制<ul>
<li>对于父进程 fork() 返回 child PID，对于子进程返回值为0<br><img src="http://qnya.pomo16.club/67.png" alt></li>
</ul>
</li>
</ul>
</li>
<li><p>程序加载和执行</p>
<ul>
<li>系统调用 exec() 加载新程序取代当前运行进程</li>
<li>exec() 示例代码<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> pid = fork();		<span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;				<span class="comment">//子进程在这里继续</span></span><br><span class="line">  exec_status = exec(<span class="string">"calc"</span>,argc,arg0,arg1,...);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Why would I execute?"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;						<span class="comment">//父进程在这里继续</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Whose your daddy?"</span>);</span><br><span class="line">  ...</span><br><span class="line">  child_status = wait(pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;<span class="comment">/*error occurred*/</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>fork() 的开销</p>
<ul>
<li>fork() 的实现开销<ul>
<li>对子进程分配内存</li>
<li>复制父进程的内存和 CPU 寄存器到子进程里</li>
<li>开销昂贵！！</li>
</ul>
</li>
<li>在 99% 的情况里，我们在调用 fork() 之后调用 exec()<ul>
<li>在 fork() 操作中内存复制是没有作用的</li>
<li>子进程将可能关闭打开的文件和连接</li>
<li>为什么不能结合它们在一个调用中？</li>
</ul>
</li>
<li>vfork()<ul>
<li>创建进程时，不再创建一个同样的内存映像</li>
<li>一些时候称为轻量级 fork()</li>
<li>子进程应该几乎立即调用 exec()</li>
<li>现在使用 Copy on Write (COW) 技术</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程加载"><a href="#进程加载" class="headerlink" title="进程加载"></a>进程加载</h3><ul>
<li>程序加载和执行系统调用 exec()<ul>
<li>允许进程”加载”一个完全不同的程序，并从 main 开始执行(即_start)</li>
<li>允许进程加载时指定启动参数(argc，argv)</li>
<li>exec 调用成功时<ul>
<li>它是相同的进程…</li>
<li>但是运行了不同的程序</li>
</ul>
</li>
<li>代码段、堆栈和堆(heap)等完全重写</li>
</ul>
</li>
</ul>
<h3 id="进程等待与退出"><a href="#进程等待与退出" class="headerlink" title="进程等待与退出"></a>进程等待与退出</h3><ul>
<li>父进程等待子进程<ul>
<li>wait() 系统调用用于父进程等待子进程的结束<ul>
<li>子进程结束时通过 exit() 向父进程返回一个值</li>
<li>父进程通过 wait() 接受并处理返回值</li>
</ul>
</li>
<li>wait() 系统调用的功能<ul>
<li>有子进程存活时，父进程进入等待状态，等待子进程的返回结果<ul>
<li>当某子进程调用 exit() 时，唤醒父进程，将 exit() 返回值作为父进程中 wait 的返回值</li>
</ul>
</li>
<li>有僵尸子进程等待时，wait()立即返回其中一个值</li>
<li>无子进程存活时，wait()立刻返回</li>
</ul>
</li>
</ul>
</li>
<li>进程的有序终止 exit()<ul>
<li>进程结束执行时调用 exit()，完成进程资源回收</li>
<li>exit() 系统调用的功能<ul>
<li>将调用参数作为进程的”结果”</li>
<li>关闭所有打开的文件等占用资源</li>
<li>释放内存</li>
<li>释放大部分进程相关的内核数据结构</li>
<li>检查是否父进程是存活着的<ul>
<li>如存活，保留结果的值直到父进程需要它，进入僵尸( zombie / defunct )状态</li>
<li>如果没有，它释放所有的数据结构，进程结果</li>
</ul>
</li>
<li>清理所有等待的僵尸进程</li>
</ul>
</li>
<li>进程终止是最终的垃圾收集(资源回收)</li>
</ul>
</li>
</ul>
<h3 id="其他进程控制系统调用"><a href="#其他进程控制系统调用" class="headerlink" title="其他进程控制系统调用"></a>其他进程控制系统调用</h3><ul>
<li>优先级控制<ul>
<li>nice() 指定进程的初始优先级</li>
<li>Unix 系统中进程优先级会随执行时间而衰减</li>
</ul>
</li>
<li>进程调试支持<ul>
<li>ptrace() 允许一个进程控制另一个进程的执行</li>
<li>设置断点和查看寄存器等</li>
</ul>
</li>
<li>定时<ul>
<li>sleep() 可以让进程在定时器的等待队列中等待指定</li>
</ul>
</li>
</ul>
<h3 id="进程控制-v-s-进程状态"><a href="#进程控制-v-s-进程状态" class="headerlink" title="进程控制 v.s. 进程状态"></a>进程控制 v.s. 进程状态</h3><p><img src="http://qnya.pomo16.club/68.png" alt></p>
<ul>
<li>exec() 实际上是执行代码过程中的一种状态</li>
</ul>
</div><div class="tags"><a href="/tags/操作系统/">操作系统</a></div><div class="post-nav"><a class="pre" href="/2019/03/20/操作系统（五）/">操作系统（五）</a><a class="next" href="/2019/03/18/操作系统（三）/">操作系统（三）</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ElasticSearch/">ElasticSearch</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/blog/">blog</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/data/">data</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">19</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/Redis/">Redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/jsp/">jsp</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/jsp/Servlet/">Servlet</a><span class="category-list-count">1</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/projects/">projects</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/web/docker/">docker</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/微信小程序/">微信小程序</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/ElasticSearch/" style="font-size: 15px;">ElasticSearch</a> <a href="/tags/Eclipse/" style="font-size: 15px;">Eclipse</a> <a href="/tags/go/" style="font-size: 15px;">go</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/rpc/" style="font-size: 15px;">rpc</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/jsp/" style="font-size: 15px;">jsp</a> <a href="/tags/JavaWeb/" style="font-size: 15px;">JavaWeb</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/七牛云/" style="font-size: 15px;">七牛云</a> <a href="/tags/CDN/" style="font-size: 15px;">CDN</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a> <a href="/tags/RSS/" style="font-size: 15px;">RSS</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/ftp/" style="font-size: 15px;">ftp</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/projects/" style="font-size: 15px;">projects</a> <a href="/tags/jre/" style="font-size: 15px;">jre</a> <a href="/tags/jdk/" style="font-size: 15px;">jdk</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/tags/Servlet/" style="font-size: 15px;">Servlet</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/hive/" style="font-size: 15px;">hive</a> <a href="/tags/集合/" style="font-size: 15px;">集合</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/操作系统/" style="font-size: 15px;">操作系统</a> <a href="/tags/数组/" style="font-size: 15px;">数组</a> <a href="/tags/String/" style="font-size: 15px;">String</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/07/15/Hive/">Hive</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/15/Hadoop核心组件/">Hadoop核心组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/05/Docker安装ES及IK分词器/">Docker安装ES相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/03/Go-数组和切片/">Go 数组、字符串和切片</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/02/Go-struct-类型Channel/">Go struct{}类型Channel</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/16/Concurrency-in-Go/">Concurrency in Go</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/22/Docker搭建FTP/">Docker搭建FTP</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/Go-Garbage-Collection/">Go Garbage Collection</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/20/git/">git</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/18/ElasticSearch/">ElasticSearch</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/pomo16" title="我的Github" target="_blank">我的Github</a><ul></ul><a href="https://blog.csdn.net/pomo16" title="我的CSDN" target="_blank">我的CSDN</a><ul></ul><a href="http://pomo16.coding.me/" title="我的老博客(荒废已久)" target="_blank">我的老博客(荒废已久)</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Atlantis.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script><!-- 添加点击爱心功能--><script type="text/javascript" src="/js/clicklove.js?v=0.0.0"></script></div></body></html>