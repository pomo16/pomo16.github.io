<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>mysql | Atlantis</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">mysql</h1><a id="logo" href="/.">Atlantis</a><p class="description">pomo16的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/toolbox/"><i class="fa fa-book"> 工具箱</i></a><a href="/community/"><i class="fa fa-comments"> 常用社区</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">mysql</h1><div class="post-meta">Jun 11, 2019<span> | </span><span class="category"><a href="/categories/mysql/">mysql</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 10.2k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 36</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><ul>
<li><a href="#一、事务">一、事务</a></li>
<li><a href="#二、范式">二、范式</a></li>
<li><a href="#三、存储引擎">三、存储引擎</a></li>
<li><a href="#四、数据类型">四、数据类型</a></li>
<li><a href="#五、索引">五、索引</a></li>
<li><a href="#六、查询性能优化">六、查询性能优化</a></li>
<li><a href="#七、分库分表">七、分库分表</a></li>
<li><a href="#八、主从复制与读写分离">八、主从复制与读写分离</a></li>
<li><a href="#九、锁">九、锁</a></li>
</ul>
<h2 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h2><h4 id="1-什么是事务？"><a href="#1-什么是事务？" class="headerlink" title="1.什么是事务？"></a>1.什么是事务？</h4><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。MySQL 默认采用自动提交模式。也就是说，如果不显式使用 <code>START TRANSACTION</code> 语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。事务简单来说：<strong>一个Session中所进行所有的操作，要么同时成功，要么同时失败。</strong></p>
<h4 id="2-ACID"><a href="#2-ACID" class="headerlink" title="2.ACID"></a>2.ACID</h4><ul>
<li><p>原子性（Atomicity）<br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
</li>
<li><p>一致性（Consistency）<br>事务前后数据的完整性必须保持一致。</p>
</li>
<li><p>隔离性（Isolation）<br>事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</p>
</li>
<li><p>持久性（Durability）</p>
<p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</p>
</li>
</ul>
<h4 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3.事务隔离级别"></a>3.事务隔离级别</h4><p>数据库定义了4个隔离级别：</p>
<ol>
<li>序列化：Serializable【可避免脏读，不可重复读，虚读】</li>
<li>可重复读：Repeatable read【可避免脏读，不可重复读】</li>
<li>已提交读：Read committed【可避免脏读】</li>
<li>未提交读：Read uncommitted【级别最低，什么都避免不了】</li>
</ol>
<ul>
<li>分别对应Connection类中的4个常量<ul>
<li>TRANSACTION_READ_UNCOMMITTED</li>
<li>TRANSACTION_READ_COMMITTED</li>
<li>TRANSACTION_REPEATABLE_READ</li>
<li>TRANSACTION_SERIALIZABLE</li>
</ul>
</li>
<li>脏读：一个事务读取到另外一个事务未提交的数据。</li>
<li>不可重复读：一个事务读取到另外一个事务已经提交的数据，也就是说一个事务可以看到其他事务所做的修改。</li>
<li>虚读(幻读)：是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。</li>
<li>简单总结：<strong>脏读是不可容忍的，不可重复读和虚读在一定的情况下是可以的【做统计的肯定就不行】</strong></li>
</ul>
<h2 id="二、范式"><a href="#二、范式" class="headerlink" title="二、范式"></a>二、范式</h2><p>数据库中的范式指的是数据库的设计规范，范式具有包含关系。一个数据库设计如果符合第二范式，一定也符合第一范式。如果符合第三范式，一定也符合第二范式…范式逐级加严，一般数据库只需满足 3NF 即可。</p>
<h4 id="1-第一范式：属性不可分"><a href="#1-第一范式：属性不可分" class="headerlink" title="1.第一范式：属性不可分"></a>1.第一范式：属性不可分</h4><p>当关系模式 R 的所有属性都不能在分解为更基本的数据单位时，称 R 是满足第一范式的，简记为 1NF。</p>
<p>1NF 是针对于数据表的列的规范，即<strong>数据表的每一列都是不可分割的原子数据项，而不能是数组，集合，记录等非原子数据项</strong>，说白了就是，不能把好几列的数据合在一起，且每一列的数据都是不可分割的。</p>
<h4 id="2-第二范式：每个非主属性完全函数依赖于键码"><a href="#2-第二范式：每个非主属性完全函数依赖于键码" class="headerlink" title="2.第二范式：每个非主属性完全函数依赖于键码"></a>2.第二范式：每个非主属性完全函数依赖于键码</h4><p>如果关系模式 R 满足第一范式，并且 R 的所有非主属性都完全依赖于 R 的每一个候选关键属性，称 R 满足第二范式，简记为 2NF。</p>
<p>2NF 基于第一范式，非码属性必须完全依赖码，即非主键数据必须依赖主键数据。“码”(主键)是数据表用来唯一区分实例或记录的数据项，若没有，可人为添加。对于第一范式针对列来说，第二范式则是针对于行的规范。<strong>第二范式需要确保数据库表中每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）</strong>。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p>
<h4 id="3-第三范式：非主属性不传递函数依赖于键码"><a href="#3-第三范式：非主属性不传递函数依赖于键码" class="headerlink" title="3.第三范式：非主属性不传递函数依赖于键码"></a>3.第三范式：非主属性不传递函数依赖于键码</h4><p>设 R 是一个满足第一范式条件的关系模式，X 是 R 的任意属性集，如果 X 非传递依赖于 R 的任意一个候选关键字，称 R 满足第三范式，简记为 3NF。</p>
<p>3NF 需要确保数据表中的<strong>每一列数据都和主键直接相关，而不能间接相关。</strong></p>
<h2 id="三、存储引擎"><a href="#三、存储引擎" class="headerlink" title="三、存储引擎"></a>三、存储引擎</h2><p>这里主要介绍两个搜索引擎：InnoDB 和 MyISAM</p>
<h4 id="1-InnoDB"><a href="#1-InnoDB" class="headerlink" title="1.InnoDB"></a>1.InnoDB</h4><p>MySQL 5.5 及之后版本的默认存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>
<p><strong>特性</strong></p>
<ul>
<li>InnoDB为事务性存储引擎</li>
<li>完全支持事物的 ACID 特性</li>
<li>Redo log （实现事务的持久性） 和 Undo log（为了实现事务的原子性，存储未完成事务log，用于回滚）</li>
<li>InnoDB支持行级锁</li>
<li>行级锁可以最大程度的支持并发</li>
<li>行级锁是由存储引擎层实现的</li>
<li>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读</li>
<li>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>可靠性要求比较高，或者要求事务</li>
<li>表更新和查询都相当的频繁，并且行锁定的机会比较大的情况。</li>
</ul>
<h4 id="2-MyISAM"><a href="#2-MyISAM" class="headerlink" title="2.MyISAM"></a>2.MyISAM</h4><p>MySQL 5.5 版本之前的默认存储引擎，在 <code>5.0</code> 以前最大表存储空间最大 <code>4G</code>，<code>5.0</code> 以后最大 <code>256TB</code>。</p>
<p>MyISAM 存储引擎由 <code>.myd</code>（数据）和 <code>.myi</code>（索引文件）组成，<code>.frm</code>文件存储表结构（所有存储引擎都有）</p>
<p><strong>特性</strong></p>
<ul>
<li>并发性和锁级别 （对于读写混合的操作不好，为表级锁，写入和读互斥）</li>
<li>表损坏修复</li>
<li>MyISAM 表支持的索引类型（全文索引）</li>
<li>MyISAM 支持表压缩（压缩后，此表为只读，不可以写入。使用 myisampack 压缩）</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>没有事务</li>
<li>只读类应用（插入不频繁，查询非常频繁）</li>
<li>空间类应用（唯一支持空间函数的引擎）</li>
<li>做很多 count 的计算</li>
</ul>
<h4 id="3-InnoDB-和-MyISAM-区别"><a href="#3-InnoDB-和-MyISAM-区别" class="headerlink" title="3.InnoDB 和 MyISAM 区别"></a>3.InnoDB 和 MyISAM 区别</h4><table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody>
<tr>
<td>主外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td>
<td>行锁，操作时只锁某一行，不对其他行有影响，适合高并发的操作</td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td>
</tr>
<tr>
<td>表空间</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>关注点</td>
<td>性能</td>
<td>事务</td>
</tr>
<tr>
<td>其他</td>
<td>MyISAM 表是保存成文件的形式，在跨平台的数据转移中使用 MyISAM 存储会省去不少的麻烦。MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</td>
<td>InnoDB 表比 MyISAM 表更安全，可以在保证数据不会丢失的情况下，切换非事务表到事务表（alter table tablename type=innodb）。InnoDB 支持在线热备份。</td>
</tr>
<tr>
<td>应用场景</td>
<td>MyISAM 管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的 SELECT 查询，那么 MyISAM 是更好的选择。</td>
<td>InnoDB 用于事务处理应用程序，具有众多特性，包括 ACID 事务支持。如果应用中需要执行大量的 INSERT 或 UPDATE 操作，则应该使用 InnoDB，这样可以提高多用户并发操作的性能。</td>
</tr>
</tbody>
</table>
<h2 id="四、数据类型"><a href="#四、数据类型" class="headerlink" title="四、数据类型"></a>四、数据类型</h2><h4 id="1-整型"><a href="#1-整型" class="headerlink" title="1.整型"></a>1.整型</h4><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p>
<h4 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2.浮点型"></a>2.浮点型</h4><p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p>
<p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p>
<h4 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3.字符串"></a>3.字符串</h4><p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</p>
<p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p>
<p>VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。</p>
<h4 id="4-时间和日期"><a href="#4-时间和日期" class="headerlink" title="4.时间和日期"></a>4.时间和日期</h4><p>MySQL 提供了两种相似的日期时间类型：DATATIME 和 TIMESTAMP。</p>
<h5 id="DATATIME"><a href="#DATATIME" class="headerlink" title="DATATIME"></a>DATATIME</h5><p>能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p>
<p>它与时区无关。</p>
<p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATATIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p>
<h5 id="TIMESTAMP"><a href="#TIMESTAMP" class="headerlink" title="TIMESTAMP"></a>TIMESTAMP</h5><p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年 到 2038 年。</p>
<p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p>
<p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p>
<p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p>
<p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p>
<h2 id="五、索引"><a href="#五、索引" class="headerlink" title="五、索引"></a>五、索引</h2><h4 id="1-索引使用场景"><a href="#1-索引使用场景" class="headerlink" title="1.索引使用场景"></a>1.索引使用场景</h4><p>索引能够轻易将查询性能提升几个数量级。</p>
<ol>
<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。</li>
<li>对于中到大型的表，索引就非常有效。</li>
<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>
</ol>
<p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<h4 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2.B+ 树"></a>2.B+ 树</h4><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p>
<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p>
<p><img src="https://pomo-blog.oss-cn-shenzhen.aliyuncs.com/article/246.png" alt></p>
<p>主要特点：<strong>内节点只存指针，叶子节点只存数据，有序</strong></p>
<h4 id="3-为什么选-B-树？"><a href="#3-为什么选-B-树？" class="headerlink" title="3.为什么选 B+ 树？"></a>3.为什么选 B+ 树？</h4><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B Tree 作为索引结构，主要有以下两个原因：</p>
<ol>
<li><p><strong>更少的检索次数</strong></p>
<p>平衡树检索数据的时间复杂度等于树高 h，而树高大致为 O(h)=O(log<sub>d</sub>N)，其中 d 为每个节点的出度。</p>
<p>红黑树的出度为 2，而 B Tree 的出度一般都非常大。红黑树的树高 h 很明显比 B Tree 大非常多，因此检索的次数也就更多。</p>
<p>B+Tree 相比于 B-Tree 更适合外存索引，因为 B+Tree 内节点去掉了 data 域，因此可以拥有更大的出度，检索效率会更高。</p>
</li>
<li><p><strong>利用磁盘预读特性</strong></p>
<p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。</p>
<p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</p>
</li>
</ol>
<h4 id="4-索引分类"><a href="#4-索引分类" class="headerlink" title="4.索引分类"></a>4.索引分类</h4><h5 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+ 树索引"></a>B+ 树索引</h5><ul>
<li>B+Tree 索引是大多数 MySQL 存储引擎的默认索引类型。</li>
<li>因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。除了用于查找，还可以用于排序和分组。</li>
<li>可以指定多个列作为索引列，多个索引列共同组成键。</li>
<li>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</li>
</ul>
<p>InnoDB 的 B+Tree 索引分为<strong>主索引</strong>和<strong>辅助索引</strong>。</p>
<p>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p><img src="https://pomo-blog.oss-cn-shenzhen.aliyuncs.com/article/247.png" alt></p>
<p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<p><img src="https://pomo-blog.oss-cn-shenzhen.aliyuncs.com/article/248.png" alt></p>
<h5 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h5><p>InnoDB 引擎有一个特殊的功能叫 “自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性，它具有以下限制：</p>
<ul>
<li>无法用于排序与分组。</li>
<li>只支持精确查找，无法用于部分查找和范围查找。</li>
</ul>
<h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>
<p>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<h5 id="空间数据索引（R-Tree）"><a href="#空间数据索引（R-Tree）" class="headerlink" title="空间数据索引（R-Tree）"></a>空间数据索引（R-Tree）</h5><p>MyISAM 存储引擎支持空间数据索引，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h4 id="5-索引种类"><a href="#5-索引种类" class="headerlink" title="5.索引种类"></a>5.索引种类</h4><ul>
<li><p>聚簇索引：数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。</p>
<ul>
<li><p>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</p>
<p>一种唯一性索引，必须指定为 primary key。一个表可以有多个唯一索引，但只能有一个主键。主键一定是唯一，唯一不一定是主键。且主键索引可以被其他表引用当外键，唯一索引不可以。</p>
</li>
</ul>
</li>
<li><p>非聚簇索引：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。</p>
<ul>
<li>普通索引：仅加速查询</li>
<li>唯一索引：加速查询 + 列值唯一（可以有null）</li>
<li>组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li>
<li>全文索引：对文本的内容进行分词，进行搜索，可以在char、varchar或text类型的列上创建。</li>
</ul>
</li>
</ul>
<h4 id="6-联合索引"><a href="#6-联合索引" class="headerlink" title="6.联合索引"></a>6.联合索引</h4><h5 id="什么是联合索引？"><a href="#什么是联合索引？" class="headerlink" title="什么是联合索引？"></a>什么是联合索引？</h5><p>两个或更多个列上的索引被称作联合索引，联合索引又叫复合索引。对于复合索引：Mysql 从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。</p>
<p>例如索引是 key index (a,b,c)，可以支持[a]、[a,b]、[a,b,c] 3种组合进行查找，但不支 [b,c] 进行查找。当最左侧字段是常量引用时，索引就十分有效。</p>
<h5 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h5><ul>
<li>需要加索引的字段，要在 where 条件中</li>
<li>数据量少的字段不需要加索引</li>
<li>如果 where 条件中是OR关系，加索引不起作用</li>
<li>符合最左原则</li>
</ul>
<h4 id="7-索引的特点"><a href="#7-索引的特点" class="headerlink" title="7.索引的特点"></a>7.索引的特点</h4><ul>
<li>可以加快数据库的检索速度</li>
<li>降低数据库插入、修改、删除等维护的速度</li>
<li>只能创建在表上，不能创建到视图上</li>
<li>既可以直接创建又可以间接创建</li>
<li>可以在优化隐藏中使用索引</li>
<li>使用查询处理器执行SQL语句，在一个表上，一次只能使用一个索引</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>创建唯一性索引，保证数据库表中每一行数据的唯一性</li>
<li>大大加快数据的检索速度，这是创建索引的最主要的原因</li>
<li>加速数据库表之间的连接，特别是在实现数据的参考完整性方面特别有意义</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li>
<li>通过使用索引，可以在查询中使用优化隐藏器，提高系统的性能</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li>
<li>索引需要占用物理空间，除了数据表占用数据空间之外，每一个索引还要占一定的物理空间，如果建立聚簇索引，那么需要的空间就会更大</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也需要维护，降低数据维护的速度</li>
</ul>
<h4 id="8-索引失效的情况"><a href="#8-索引失效的情况" class="headerlink" title="8.索引失效的情况"></a>8.索引失效的情况</h4><ul>
<li><p>如果MySQL估计使用<strong>全表扫秒比使用索引快</strong>，则不使用索引。</p>
<p>例：如果列 key 均匀分布在 1 和 100 之间，下面的查询使用索引就不是很好：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table_name where key&gt;1 and key&lt;90;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果<strong>条件中有 or</strong>，即使其中有条件带索引也不会使用。</p>
<p>例：如果在 key1 上有索引而在 key2 上没有索引，则该查询也不会走索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table_name where key1=&apos;a&apos; or key2=&apos;b&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复合索引，如果索引列<strong>不是复合索引的第一部分</strong>，则不使用索引。（即不符合最左前缀）</p>
<p>例：复合索引为(key1,key2)，则下列查询将不会使用索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table_name where key2=&apos;b&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果 <strong>like 是以 % 开始的</strong>，则该列上的索引不会被使用。</p>
<p>例：下列查询即使 key1 上存在索引，也不会被使用如果列类型是字符串，那一定要在条件中使用引号引起来，否则不会使用索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table_name where key1 like &apos;%a&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果列为字符串，则 where 条件中必须将字符常量值加引号，否则即使该列上存在索引，也不会被使用。</p>
<p>例：如果key1列保存的是字符串，即使key1上有索引，也不会被使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table_name where key1=1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果使用 MEMORY/HEAP 表，并且 where 条件中不使用 “=” 进行索引列，那么不会用到索引，head 表只有在 “=” 的条件下才会使用索引。</p>
</li>
</ul>
<h4 id="9-在什么情况下适合建立索引？"><a href="#9-在什么情况下适合建立索引？" class="headerlink" title="9.在什么情况下适合建立索引？"></a>9.在什么情况下适合建立索引？</h4><ul>
<li>为经常出现在关键字 order by、group by、distinct 后面的字段，建立索引。</li>
<li>在 union 等集合操作的结果集字段上，建立索引。其建立索引的目的同上。</li>
<li>为经常用作查询选择 where 后的字段，建立索引。</li>
<li>在经常用作表连接 join 的属性上，建立索引。</li>
<li>考虑使用索引覆盖。对数据很少被更新的表，如果用户经常只查询其中的几个字段，可以考虑在这几个字段上建立索引，从而将表的扫描改变为索引的扫描。</li>
</ul>
<h4 id="10-主键、外键和索引的区别"><a href="#10-主键、外键和索引的区别" class="headerlink" title="10.主键、外键和索引的区别"></a>10.主键、外键和索引的区别</h4><table>
<thead>
<tr>
<th></th>
<th>定义</th>
<th>作用</th>
<th>个数</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>主键</strong></td>
<td>唯一标识一条记录，不能有重复的，不允许为空</td>
<td>用来保证数据完整性</td>
<td>主键只能有一个</td>
</tr>
<tr>
<td><strong>外键</strong></td>
<td>表的外键是另一表的主键，外键可以有重复的，可以是空值</td>
<td>用来和其他表建立联系用的</td>
<td>一个表可以有多个外键</td>
</tr>
<tr>
<td><strong>索引</strong></td>
<td>该字段没有重复值，但可以有一个空值</td>
<td>是提高查询排序的速度</td>
<td>一个表可以有多个惟一索引</td>
</tr>
</tbody>
</table>
<h4 id="11-SQL-约束有哪几种？"><a href="#11-SQL-约束有哪几种？" class="headerlink" title="11. SQL 约束有哪几种？"></a>11. SQL 约束有哪几种？</h4><ul>
<li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li>
<li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li>
<li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li>
<li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li>
<li>CHECK: 用于控制字段的值范围。</li>
</ul>
<h2 id="六、查询性能优化"><a href="#六、查询性能优化" class="headerlink" title="六、查询性能优化"></a>六、查询性能优化</h2><h4 id="1-用-Explain-进行分析"><a href="#1-用-Explain-进行分析" class="headerlink" title="1.用 Explain 进行分析"></a>1.用 Explain 进行分析</h4><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>
<p>比较重要的字段有：</p>
<ul>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>key : 使用的索引</li>
<li>rows : 扫描的行数</li>
</ul>
<h4 id="2-优化数据访问"><a href="#2-优化数据访问" class="headerlink" title="2.优化数据访问"></a>2.优化数据访问</h4><ul>
<li>减少请求的数据量<ul>
<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>
<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>
</li>
<li>减少服务器端扫描的行数<ul>
<li>最有效的方式是使用索引来覆盖查询。</li>
</ul>
</li>
</ul>
<h4 id="3-重构查询方式"><a href="#3-重构查询方式" class="headerlink" title="3.重构查询方式"></a>3.重构查询方式</h4><ul>
<li><p>切分大查询</p>
<p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELEFT FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rows_affected = 0</span><br><span class="line">do &#123;</span><br><span class="line">    rows_affected = do_query(</span><br><span class="line">    &quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)</span><br><span class="line">&#125; while rows_affected &gt; 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>分解大连接查询</p>
<p>将一个大连接查询（JOIN）分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有：</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可扩展。</li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tab</span><br><span class="line">JOIN tag_post ON tag_post.tag_id=tag.id</span><br><span class="line">JOIN post ON tag_post.post_id=post.id</span><br><span class="line">WHERE tag.tag=&apos;mysql&apos;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tag WHERE tag=&apos;mysql&apos;;</span><br><span class="line">SELECT * FROM tag_post WHERE tag_id=1234;</span><br><span class="line">SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="七、分库分表"><a href="#七、分库分表" class="headerlink" title="七、分库分表"></a>七、分库分表</h2><p>简单来说，数据的切分就是通过某种特定的条件，将我们存放在同一个数据库中的数据分散存放到多个数据库（主机）中，以达到分散单台设备负载的效果，即分库分表。</p>
<p>数据的切分根据其切分规则的类型，可以分为如下两种切分模式。</p>
<ul>
<li>垂直（纵向）切分：把单一的表拆分成多个表，并分散到不同的数据库（主机）上。</li>
<li>水平（横向）切分：根据表中数据的逻辑关系，将同一个表中的数据按照某种条件拆分到多台数据库（主机）上。</li>
</ul>
<h4 id="1-水平切分"><a href="#1-水平切分" class="headerlink" title="1.水平切分"></a>1.水平切分</h4><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p>
<p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p>
<p><img src="https://pomo-blog.oss-cn-shenzhen.aliyuncs.com/article/249.png" alt></p>
<h5 id="Sharding-优点"><a href="#Sharding-优点" class="headerlink" title="Sharding 优点"></a>Sharding 优点</h5><ul>
<li>单库单表的数据保持在一定的量级，有助于性能的提高</li>
<li>切分的表的结构相同，应用层改造较少，只需要增加路由规则即可</li>
<li>提高了系统的稳定性和负载能力</li>
</ul>
<h5 id="Sharding-缺点"><a href="#Sharding-缺点" class="headerlink" title="Sharding 缺点"></a>Sharding 缺点</h5><ul>
<li>切分后，数据是分散的，很难利用数据库的 join 操作，跨库 join 性能较差</li>
<li>拆分规则难以抽象</li>
<li>分片事务的一致性难以解决</li>
<li>数据扩容的难度和维护量极大</li>
</ul>
<h5 id="Sharding-策略"><a href="#Sharding-策略" class="headerlink" title="Sharding 策略"></a>Sharding 策略</h5><ul>
<li>哈希取模：hash(key) % NUM_DB<ul>
<li>比如按照 userId mod 64，将数据分布在64个服务器上</li>
</ul>
</li>
<li>范围：可以是 ID 范围也可以是时间范围<ul>
<li>比如每台服务器计划存放一个亿的数据,先将数据写入服务器 A.一旦服务器 A 写满,则将数据写入服务器 B,以此类推. 这种方式的好处是扩展方便.数据在各个服务器上分布均匀</li>
</ul>
</li>
<li>映射表：使用单独的一个数据库来存储映射关系</li>
</ul>
<h5 id="Sharding-存在的问题及解决方案"><a href="#Sharding-存在的问题及解决方案" class="headerlink" title="Sharding 存在的问题及解决方案"></a>Sharding 存在的问题及解决方案</h5><ul>
<li>事务问题：使用分布式事务来解决，比如 XA 接口。</li>
<li>JOIN：可以将原来的 JOIN 查询分解成多个单表查询，然后在用户程序中进行 JOIN。</li>
<li>ID 唯一性<ul>
<li>使用全局唯一 ID：GUID。</li>
<li>为每个分片指定一个 ID 范围。</li>
<li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)。</li>
</ul>
</li>
</ul>
<h4 id="2-垂直切分"><a href="#2-垂直切分" class="headerlink" title="2.垂直切分"></a>2.垂直切分</h4><p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p>
<p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p>
<p><img src="https://pomo-blog.oss-cn-shenzhen.aliyuncs.com/article/250.png" alt></p>
<h5 id="垂直切分的优点"><a href="#垂直切分的优点" class="headerlink" title="垂直切分的优点"></a>垂直切分的优点</h5><ul>
<li>拆分后业务清晰，拆分规则明确</li>
<li>系统之间进行整合或扩展很容易</li>
<li>按照成本、应用的等级、应用的类型等将表放到不同的机器上，便于管理</li>
<li>便于实现<strong>动静分离</strong>、<strong>冷热分离</strong>的数据库表的设计模式</li>
<li>数据维护简单</li>
</ul>
<h5 id="垂直切分的缺点"><a href="#垂直切分的缺点" class="headerlink" title="垂直切分的缺点"></a>垂直切分的缺点</h5><ul>
<li>部分业务表无法关联（Join），只能通过接口方式解决，提高了系统的复杂度</li>
<li>受每种业务的不同限制，存在单库性能瓶颈，不易进行数据扩展和提升性能</li>
<li>事务处理复杂</li>
</ul>
<h4 id="3-垂直切分和水平切分的共同点"><a href="#3-垂直切分和水平切分的共同点" class="headerlink" title="3.垂直切分和水平切分的共同点"></a>3.垂直切分和水平切分的共同点</h4><ul>
<li>存在分布式事务的问题</li>
<li>存在跨节点 Join 的问题</li>
<li>存在跨节点合并排序、分页的问题</li>
<li>存在多数据源管理的问题</li>
</ul>
<h2 id="八、主从复制与读写分离"><a href="#八、主从复制与读写分离" class="headerlink" title="八、主从复制与读写分离"></a>八、主从复制与读写分离</h2><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制文件（binlog）中。</li>
<li><strong>I/O 线程</strong> ：负责从主服务器上读取二进制日志文件，并写入从服务器的中继日志中。</li>
<li><strong>SQL 线程</strong> ：负责读取中继日志并重放其中的 SQL 语句。</li>
</ul>
<p><img src="https://pomo-blog.oss-cn-shenzhen.aliyuncs.com/article/251.png" alt></p>
<h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>主服务器用来处理写操作以及实时性要求比较高的读操作，而从服务器用来处理读操作。</p>
<p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p>
<p>MySQL 读写分离能提高性能的原因在于：</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以配置 MyISAM 引擎，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
<p><img src="https://pomo-blog.oss-cn-shenzhen.aliyuncs.com/article/252.png" alt></p>
<h2 id="九、锁"><a href="#九、锁" class="headerlink" title="九、锁"></a>九、锁</h2><p>MySQL/InnoDB 的加锁，一直是一个面试中常问的话题。例如，数据库如果有高并发请求，如何保证数据完整性？产生死锁问题如何排查并解决？在工作过程中，也会经常用到，乐观锁，排它锁等。</p>
<p>注：MySQL 是一个支持插件式存储引擎的数据库系统。下面的所有介绍，都是基于 InnoDB 存储引擎，其他引擎的表现，会有较大的区别。</p>
<p><strong>版本查看</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select version();</span><br></pre></td></tr></table></figure>
<p><strong>存储引擎查看</strong></p>
<p>MySQL 给开发者提供了查询存储引擎的功能，我这里使用的是 MySQL5.6.4，可以使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW ENGINES</span><br></pre></td></tr></table></figure>
<h4 id="1-乐观锁"><a href="#1-乐观锁" class="headerlink" title="1.乐观锁"></a>1.乐观锁</h4><p>假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p>
<p>用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将 version 字段的值一同读出，数据每更新一次，对此 version 值加1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的 version 值进行比对，如果数据库表当前版本号与第一次取出来的 version 值相等，则予以更新，否则认为是过期数据。例：</p>
<p>a. 数据库表设计三个字段，分别是 id,value,version</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,value,version from TABLE where id=#&#123;id&#125;</span><br></pre></td></tr></table></figure>
<p>b. 每次更新表中的value字段时，为了防止发生冲突，需要这样操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update TABLE</span><br><span class="line">set value=2,version=version+1</span><br><span class="line">where id=#&#123;id&#125; and version=#&#123;version&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-悲观锁"><a href="#2-悲观锁" class="headerlink" title="2.悲观锁"></a>2.悲观锁</h4><p>假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p>
<p>悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟 Java 中的 synchronized 很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</p>
<p>说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是<strong>共享锁</strong>与<strong>排它锁</strong>。<strong>共享锁和排它锁是悲观锁的不同的实现</strong>，它俩都属于悲观锁的范畴。以排它锁为例：</p>
<p>要使用悲观锁，我们必须关闭 mysql 数据库的自动提交属性，因为 MySQL 默认使用 autocommit 模式，也就是说，当你执行一个更新操作后，MySQL 会立刻将结果进行提交。我们可以使用命令设置 MySQL 为非 autocommit 模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">set autocommit=0;</span><br><span class="line"># 设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：</span><br><span class="line"></span><br><span class="line"># 1. 开始事务 (三者选一就可以)</span><br><span class="line">begin; / begin work; / start transaction;</span><br><span class="line"></span><br><span class="line"># 2. 查询表信息</span><br><span class="line">select status from TABLE where id=1 for update;</span><br><span class="line"></span><br><span class="line"># 3. 插入一条数据</span><br><span class="line">insert into TABLE (id,value) values (2,2);</span><br><span class="line"></span><br><span class="line"># 4. 修改数据为</span><br><span class="line">update TABLE set value=2 where id=1;</span><br><span class="line"></span><br><span class="line"># 5. 提交事务</span><br><span class="line">commit;/commit work;</span><br></pre></td></tr></table></figure>
<h4 id="3-共享锁"><a href="#3-共享锁" class="headerlink" title="3.共享锁"></a>3.共享锁</h4><p>共享锁又称<strong>读锁</strong>（read lock），是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。</p>
<p>如果事务 T 对数据 A 加上共享锁后，则其他事务只能对 A 再加共享锁，不能加排他锁。获得共享锁的事务只能读数据，不能修改数据。</p>
<p>打开第一个查询窗口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#三者选一就可以</span><br><span class="line">begin; / begin work; / start transaction;</span><br><span class="line"></span><br><span class="line">SELECT * from TABLE where id = 1  lock in share mode;</span><br></pre></td></tr></table></figure>
<p>然后在另一个查询窗口中，对 id 为 1 的数据进行更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update TABLE set name=&quot;www.souyunku.com&quot; where id =1;</span><br></pre></td></tr></table></figure>
<p>此时，操作界面进入了卡顿状态，过了超时间，提示错误信息</p>
<p>如果在超时前，执行 <code>commit</code>，此更新语句就会成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SQL]update  test_one set name=&quot;www.souyunku.com&quot; where id =1;</span><br><span class="line">[Err] 1205 - Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure>
<p>加上共享锁后，也提示错误信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update test_one set name=&quot;www.souyunku.com&quot; where id =1 lock in share mode;</span><br><span class="line">[SQL]update  test_one set name=&quot;www.souyunku.com&quot; where id =1 lock in share mode;</span><br><span class="line">[Err] 1064 - You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;lock in share mode&apos; at line 1</span><br></pre></td></tr></table></figure>
<p>在查询语句后面增加 <code>lock in share mode</code>，MySQL 会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。</p>
<p>加上共享锁后，对于 <code>update,insert,delete</code> 语句会自动加排它锁。</p>
<h4 id="4-排它锁"><a href="#4-排它锁" class="headerlink" title="4.排它锁"></a>4.排它锁</h4><p>排他锁 exclusive lock（也叫 writer lock）又称<strong>写锁</strong>。</p>
<p><strong>排它锁是悲观锁的一种实现，在上面悲观锁也介绍过</strong>。</p>
<p>若事务 1 对数据对象 A 加上 X 锁，事务 1 可以读 A 也可以修改 A，其他事务不能再对 A 加任何锁，直到事物 1 释放 A 上的锁。这保证了其他事务在事物 1 释放 A 上的锁之前不能再读取和修改 A。排它锁会阻塞所有的排它锁和共享锁。</p>
<p>读取为什么要加读锁呢：防止数据在被读取的时候被别的线程加上写锁。</p>
<p>使用方式：在需要执行的语句后面加上 <code>for update</code> 就可以了。</p>
<h4 id="5-行锁"><a href="#5-行锁" class="headerlink" title="5.行锁"></a>5.行锁</h4><p>行锁又分<strong>共享锁</strong>和<strong>排他锁</strong>，由字面意思理解，就是给某一行加上锁，也就是一条记录加上锁。</p>
<p>注意：行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。</p>
<p><strong>共享锁：</strong></p>
<p>名词解释：共享锁又叫做读锁，所有的事务只能对其进行读操作不能写操作，加上共享锁后在事务结束之前其他事务只能再加共享锁，除此之外其他任何类型的锁都不能再加了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#结果集的数据都会加共享锁</span><br><span class="line">SELECT * from TABLE where id = &quot;1&quot;  lock in share mode;</span><br></pre></td></tr></table></figure>
<p><strong>排他锁：</strong></p>
<p>名词解释：若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁，其他进程可以读取，不能进行写操作，需等待其释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select status from TABLE where id=1 for update;</span><br></pre></td></tr></table></figure>
<p>可以参考之前演示的共享锁，排它锁语句</p>
<p>由于对于表中 id 字段为主键，就也相当于索引。执行加锁时，会将 id 这个索引为 1 的记录加上锁，那么这个锁就是行锁。</p>
<h4 id="6-表锁"><a href="#6-表锁" class="headerlink" title="6.表锁"></a>6.表锁</h4><p><strong>如何加表锁</strong></p>
<p>innodb 的行锁是在有索引的情况下,没有索引的表是锁定全表的。</p>
<p><strong>Innodb中的行锁与表锁</strong></p>
<p>前面提到过，在 Innodb 引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候或只锁住一行呢？ 只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</p>
<p>在实际应用中，要特别注意 InnoDB 行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p>
<p>行级锁都是基于索引的，如果一条 SQL 语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。</p>
<h4 id="7-死锁"><a href="#7-死锁" class="headerlink" title="7. 死锁"></a>7. 死锁</h4><p>死锁（Deadlock） 所谓死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。</p>
<p>解除正在死锁的状态有两种方法：</p>
<p><strong>第一种</strong>：</p>
<p>查询是否锁表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show OPEN TABLES where In_use &gt; 0;</span><br></pre></td></tr></table></figure>
<p>查询进程（如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show processlist</span><br></pre></td></tr></table></figure>
<p>杀死进程id（就是上面命令的id列）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill id</span><br></pre></td></tr></table></figure>
<p><strong>第二种</strong>：</p>
<p>查看当前的事务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;</span><br></pre></td></tr></table></figure>
<p>查看当前锁定的事务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;</span><br></pre></td></tr></table></figure>
<p>查看当前等锁的事务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</span><br></pre></td></tr></table></figure>
<p>杀死进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill 进程ID</span><br></pre></td></tr></table></figure>
<p>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。 产生死锁的四个必要条件：</p>
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p>虽然不能完全避免死锁，但可以使死锁的数量减至最少。将死锁减至最少可以增加事务的吞吐量并减少系统开销，因为只有很少的事务回滚，而回滚会取消事务执行的所有工作。由于死锁时回滚而由应用程序重新提交。</p>
<p><strong>下列方法有助于最大限度地降低死锁：</strong></p>
<ol>
<li>按同一顺序访问对象</li>
<li>避免事务中的用户交互</li>
<li>保持事务简短并在一个批处理中</li>
<li>使用低隔离级别</li>
<li>使用绑定连接</li>
</ol>
</div><div class="tags"><a href="/tags/mysql/">mysql</a></div><div class="post-nav"><a class="pre" href="/2019/06/23/Java线程池/">Java线程池</a><a class="next" href="/2019/06/11/计算机网络基础/">计算机网络基础</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ElasticSearch/">ElasticSearch</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/blog/">blog</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/data/">data</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">19</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/Redis/">Redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/jsp/">jsp</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/jsp/Servlet/">Servlet</a><span class="category-list-count">1</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/projects/">projects</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/web/docker/">docker</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/微信小程序/">微信小程序</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/ElasticSearch/" style="font-size: 15px;">ElasticSearch</a> <a href="/tags/Eclipse/" style="font-size: 15px;">Eclipse</a> <a href="/tags/go/" style="font-size: 15px;">go</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/jsp/" style="font-size: 15px;">jsp</a> <a href="/tags/JavaWeb/" style="font-size: 15px;">JavaWeb</a> <a href="/tags/rpc/" style="font-size: 15px;">rpc</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/七牛云/" style="font-size: 15px;">七牛云</a> <a href="/tags/CDN/" style="font-size: 15px;">CDN</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a> <a href="/tags/RSS/" style="font-size: 15px;">RSS</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/ftp/" style="font-size: 15px;">ftp</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/projects/" style="font-size: 15px;">projects</a> <a href="/tags/jre/" style="font-size: 15px;">jre</a> <a href="/tags/jdk/" style="font-size: 15px;">jdk</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/tags/Servlet/" style="font-size: 15px;">Servlet</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/hive/" style="font-size: 15px;">hive</a> <a href="/tags/集合/" style="font-size: 15px;">集合</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/操作系统/" style="font-size: 15px;">操作系统</a> <a href="/tags/数组/" style="font-size: 15px;">数组</a> <a href="/tags/String/" style="font-size: 15px;">String</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/07/15/Hive/">Hive</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/15/Hadoop核心组件/">Hadoop核心组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/05/Docker安装ES及IK分词器/">Docker安装ES相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/03/Go-数组和切片/">Go 数组、字符串和切片</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/02/Go-struct-类型Channel/">Go struct{}类型Channel</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/16/Concurrency-in-Go/">Concurrency in Go</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/22/Docker搭建FTP/">Docker搭建FTP</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/Go-Garbage-Collection/">Go Garbage Collection</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/20/git/">git</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/18/ElasticSearch/">ElasticSearch</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/pomo16" title="我的Github" target="_blank">我的Github</a><ul></ul><a href="https://blog.csdn.net/pomo16" title="我的CSDN" target="_blank">我的CSDN</a><ul></ul><a href="http://pomo16.coding.me/" title="我的老博客(荒废已久)" target="_blank">我的老博客(荒废已久)</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Atlantis.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script><!-- 添加点击爱心功能--><script type="text/javascript" src="/js/clicklove.js?v=0.0.0"></script></div></body></html>