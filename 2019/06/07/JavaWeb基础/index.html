<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>JavaWeb基础 | Atlantis</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JavaWeb基础</h1><a id="logo" href="/.">Atlantis</a><p class="description">pomo16的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/toolbox/"><i class="fa fa-book"> 工具箱</i></a><a href="/community/"><i class="fa fa-comments"> 常用社区</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JavaWeb基础</h1><div class="post-meta">Jun 7, 2019<span> | </span><span class="category"><a href="/categories/java/">java</a><a href="/categories/java/jsp/">jsp</a><a href="/categories/java/jsp/Servlet/">Servlet</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 4.1k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 15</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p><a href="#1-什么是-Servlet？">1. 什么是 Servlet？</a></p>
<p><a href="#2-Servlet-类的继承关系">2. Servlet 类的继承关系</a></p>
<p><a href="#3-Servlet-实现方式">3. Servlet 实现方式</a></p>
<p><a href="#4-Tomcat-容器等级">4. Tomcat 容器等级</a></p>
<p><a href="#5-Servlet-执行流程">5. Servlet 执行流程</a></p>
<p><a href="#6-Servlet-生命周期">6. Servlet 生命周期</a></p>
<p><a href="#7-Tomcat-装载-Servlet-的三种情况">7. Tomcat 装载 Servlet 的三种情况</a></p>
<p><a href="#8-forward-和-redirect">8. forward 和 redirect</a></p>
<p><a href="#9-Jsp-和-Servlet-的区别">9. Jsp 和 Servlet 的区别</a></p>
<p><a href="#10-Tomcat-和-Servlet-的联系">10. Tomcat 和 Servlet 的联系</a></p>
<p><a href="#11-cookie-和-session">11. cookie 和 session</a></p>
<p><a href="#12-JavaEE-中的三层结构和-MVC">12. JavaEE 中的三层结构和 MVC</a></p>
<p><a href="#13-RESTful-架构">13. RESTful 架构</a></p>
<h2 id="1-什么是-Servlet？"><a href="#1-什么是-Servlet？" class="headerlink" title="1. 什么是 Servlet？"></a>1. 什么是 Servlet？</h2><p>Servlet 是在服务器上运行的小程序。一个 servlet 就是一个 Java 类，并且可以通过 “请求—响应” 编程模式来访问的这个驻留在服务器内存里的 servlet 程序。</p>
<h2 id="2-Servlet-类的继承关系"><a href="#2-Servlet-类的继承关系" class="headerlink" title="2. Servlet 类的继承关系"></a>2. Servlet 类的继承关系</h2><p><img src="http://qnya.pomo16.club/221.png" alt></p>
<h2 id="3-Servlet-实现方式"><a href="#3-Servlet-实现方式" class="headerlink" title="3. Servlet 实现方式"></a>3. Servlet 实现方式</h2><ul>
<li><p>实现 javax.servlet.Servlet 接口</p>
</li>
<li><p>继承 javax.servlet.GenericServlet 类</p>
</li>
<li><p>继承 javax.servlet.http.HttpServlet 类</p>
<p>通常会去继承 HttpServlet 类来完成 Servlet</p>
</li>
</ul>
<h2 id="4-Tomcat-容器等级"><a href="#4-Tomcat-容器等级" class="headerlink" title="4. Tomcat 容器等级"></a>4. Tomcat 容器等级</h2><p>Tomcat 的容器分为4个等级，Servlet 的容器管理 Context 容器，一个 Context 对应一个 Web 工程。</p>
<p><img src="http://qnya.pomo16.club/222.png" alt></p>
<h2 id="5-Servlet-执行流程"><a href="#5-Servlet-执行流程" class="headerlink" title="5. Servlet 执行流程"></a>5. Servlet 执行流程</h2><p>主要描述了从浏览器到服务器，再从服务器到浏览器的整个执行过程。</p>
<p><strong>1.浏览器请求</strong></p>
<p><img src="http://qnya.pomo16.club/223.png" alt></p>
<p>浏览器向服务器请求时，服务器不会直接执行我们的类，而是到 web.xml 里寻找路径名。</p>
<p>① 浏览器输入访问路径后，携带了请求行，头，体 </p>
<p>② 根据访问路径找到已注册的 servlet 名称</p>
<p>③ 根据映射找到对应的 servlet 名 </p>
<p>④ 根据根据 servlet 名找到我们全限定类名，既我们自己写的类</p>
<p><strong>2.服务器创建对象</strong></p>
<p><img src="http://qnya.pomo16.club/224.png" alt></p>
<p>① 服务器找到全限定类名后，通过反射创建对象，同时也创建了 servletConfig，里面存放了一些初始化信息（注意服务器只会创建一次 servlet 对象，所以 servletConfig 也只有一个）</p>
<p><strong>3.调用 init 方法</strong></p>
<p><img src="http://qnya.pomo16.club/225.png" alt></p>
<p>① 对象创建好之后，首先要执行 init 方法，但是我们发现我们自定义类下没有 init 方法，所以程序会到其父类 HttpServlet 里找</p>
<p>② 我们发现 HttpServlet 里也没有 init 方法，所以继续向上找，既向其父类 GenericServlet 中继续寻找，在 GenericServlet 中我们发现了 init 方法，则执行 init 方法（对接口 Servlet 中的 init 方法进行了重写）</p>
<p>注意： 在 GenericServlet 中执行 public void init(ServletConfig config) 方法的时候，又调用了自己无参无方法体的 init() 方法，其目的是为了方便开发者，如果开发者在初始化的过程中需要实现一些功能，可以重写此方法。</p>
<p><strong>4.调用 service 方法</strong></p>
<p><img src="http://qnya.pomo16.club/226.png" alt></p>
<p>接着，服务器会先创建两个对象：ServletRequest 请求对象和 ServletResponse 响应对象，用来封装浏览器的请求数据和封装向浏览器的响应数据</p>
<p> ① 接着服务器会默认在我们写的类里寻找 service(ServletRequest req, ServletResponse res) 方法，但是 DemoServlet 中不存在，那么会到其父类中寻找 </p>
<p>② 到父类 HttpServlet 中发现有此方法，则直接调用此方法，并将之前创建好的两个对象传入</p>
<p>③ 然后将传入的两个参数强转，并调用 HttpServlet 下的另外个 service 方法</p>
<p>④ 接着执行 <code>service(HttpServletRequest req, HttpServletResponse resp)</code> 方法，在此方法内部进行了判断请求方式，并执行 doGet 和 doPost，但是 doGet 和 doPost 方法已经被我们自己重写了，所以会执行我们重写的方法</p>
<p>看到这里，你或许有疑问：为什么我们不直接重写 service 方法？ 因为如果重写 service 方法的话，我们需要将强转，以及一系列的安全保护判断重新写一遍，会存在安全隐患。</p>
<p><strong>4.向浏览器响应</strong></p>
<p><img src="http://qnya.pomo16.club/227.png" alt></p>
<h2 id="6-Servlet-生命周期"><a href="#6-Servlet-生命周期" class="headerlink" title="6. Servlet 生命周期"></a>6. Servlet 生命周期</h2><ul>
<li><strong>加载和实例化</strong>：Servlet 容器负责加载和实例化 Servlet 对象。</li>
<li><strong>初始化</strong>：<code>void init(ServletConfig servletConfig)</code> Servlet 对象创建之后马上执行的初始化方法，只执行一次。</li>
<li><strong>请求处理</strong>：<code>void service(ServletRequest servletRequest, ServletResponse servletResponse)</code> 每次处理请求都是在调用这个方法，它会被调用多次</li>
<li><strong>销毁</strong>：<code>void destroy()</code> 在 Servlet 被销毁之前调用，负责释放 Servlet 对象占用的资源的方法</li>
</ul>
<p><strong>服务器执行流程</strong></p>
<ol>
<li>Servlet 类由自己编写，但对象由服务器来创建，并由服务器来调用相应的方法。　</li>
<li>服务器启动时 ( web.xml 中配置 <code>load-on-startup=1</code>，默认为0 ) 或者第一次请求该 Servlet 时，就会初始化一个 Servlet 对象，也就是会执行初始化方法 init(ServletConfig conf)。</li>
<li>该 Servlet 对象去处理所有客户端请求，在 <code>service(ServletRequest req，ServletResponse res)</code> 方法中执行。</li>
<li>最后服务器关闭时，才会销毁这个 Servlet 对象，执行 destroy() 方法。</li>
</ol>
<p><img src="http://qnya.pomo16.club/228.png" alt></p>
<p><strong>一些问题</strong></p>
<p>Servlet 何时创建？ 答：默认第一次访问 Servlet 时创建该对象(调用 init() 方法)</p>
<p>Servlet何时销毁？答：服务器关闭 Servlet 就销毁了(调用 destroy() 方法)</p>
<p>每次访问必须执行的方法是什么？答：public void service(ServletRequest arg0, ServletResponse arg1)</p>
<h2 id="7-Tomcat-装载-Servlet-的三种情况"><a href="#7-Tomcat-装载-Servlet-的三种情况" class="headerlink" title="7. Tomcat 装载 Servlet 的三种情况"></a>7. Tomcat 装载 Servlet 的三种情况</h2><ul>
<li><p>Servlet 容器启动时自动装载某些 Servlet，实现它只需要在 web.xml 文件中的 <code>&lt;servlet&gt;&lt;/servlet&gt;</code> 之间添加以下代码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中，数字越小表示优先级越高。启动和关闭 Tomcat：优先级高的先启动也先关闭。</p>
</li>
<li><p>客户端首次向某个 Servlet 发送请求。</p>
</li>
<li><p>Servlet 类被修改后，Tomcat 容器会重新装载 Servlet。</p>
</li>
</ul>
<h2 id="8-forward-和-redirect"><a href="#8-forward-和-redirect" class="headerlink" title="8. forward 和 redirect"></a>8. forward 和 redirect</h2><p>Servlet 中主要有两种实现跳转的方式：forward 与 redirect 方式。</p>
<p>forward 是服务器内部的重定向，服务器直接访问目标地址的 URL，把那个 URL 的响应内容读取过来，而客户端并不知道，因此在客户端浏览器的地址栏中不会显示转向后的地址，还是原来的地址。由于在整个定向的过程中用的是同一个 Request，因此 forward 会将 Request 的信息带到被定向的 JSP 或 Servlet 中使用。</p>
<p>redirect 则是客户端的重定向，是完全的跳转，即客户端浏览器会获取到跳转后的地址，然后重新发送请求，因此浏览器中会显示跳转后的地址。同事，由于这种方式比 forward 方式多了一次网络请求，因此其效率要低于 forward 方式。需要注意的是，客户端的重定向可以通过设置特定的 HTTP 头或改写 JavaScript 脚本实现。</p>
<p><img src="http://qnya.pomo16.club/229.png" alt></p>
<p>鉴于以上的区别，一般当 forward 方式可以满足需求时，尽可能地使用 forward 方式。但在有些情况下，例如，需要跳转到下一个其他服务器上的资源，则必须使用 redirect 方式。</p>
<p><strong>引申：filter的作用是什么？主要实现什么方法？</strong></p>
<p>filter 使用户可以改变一个 request 并且修改一个 response。filter 不是一个 Servlet，它不能产生一个 response，但它能够在一个 request 到达 Servlet 之前预处理 request，也可以在离开 Servlet 时处理 response。filter 其实是一个 “Servlet Chaining” (Servler 链)。</p>
<p>一个 filter 的作用包括以下几个方面：</p>
<ol>
<li>在 Servlet 被调用之前截获</li>
<li>在 Servlet 被调用之前检查 Servlet Request</li>
<li>根据需要修改 Request 头和 Request 数据</li>
<li>根据需要修改 Response 头和 Response 数据</li>
<li>在 Servlet 被调用之后截获</li>
</ol>
<h2 id="9-Jsp-和-Servlet-的区别"><a href="#9-Jsp-和-Servlet-的区别" class="headerlink" title="9. Jsp 和 Servlet 的区别"></a>9. Jsp 和 Servlet 的区别</h2><p><strong>不同之处在哪？</strong></p>
<ul>
<li>Servlet 在 Java 代码中通过 HttpServletResponse 对象动态输出 HTML 内容</li>
<li>JSP 在静态 HTML 内容中嵌入 Java 代码，Java 代码被动态执行后生成 HTML 内容</li>
</ul>
<p><strong>各自的特点</strong></p>
<ul>
<li>Servlet 能够很好地组织业务逻辑代码，但是在 Java 源文件中通过字符串拼接的方式生成动态 HTML 内容会导致代码维护困难、可读性差</li>
<li>JSP 虽然规避了 Servlet 在生成 HTML 内容方面的劣势，但是在 HTML 中混入大量、复杂的业务逻辑同样也是不可取的</li>
</ul>
<p><strong>通过 MVC 双剑合璧</strong></p>
<p>既然 JSP 和 Servlet 都有自身的适用环境，那么能否扬长避短，让它们发挥各自的优势呢？答案是肯定的——MVC(Model-View-Controller)模式非常适合解决这一问题。</p>
<p>MVC模式（Model-View-Controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）：</p>
<ul>
<li>Controller——负责转发请求，对请求进行处理</li>
<li>View——负责界面显示</li>
<li>Model——业务功能编写（例如算法实现）、数据库设计以及数据存取操作实现</li>
</ul>
<p>在 JSP/Servlet 开发的软件系统中，这三个部分的描述如下所示：</p>
<p><img src="http://qnya.pomo16.club/230.png" alt></p>
<ol>
<li>Web 浏览器发送 HTTP 请求到服务端，被 Controller(Servlet) 获取并进行处理（例如参数解析、请求转发）</li>
<li>Controller(Servlet) 调用核心业务逻辑——Model部分，获得结果</li>
<li>Controller(Servlet) 将逻辑处理结果交给 View（JSP），动态输出 HTML 内容</li>
<li>动态生成的 HTML 内容返回到浏览器显示</li>
</ol>
<p>MVC 模式在 Web 开发中的好处是非常明显，它规避了 JSP 与 Servlet 各自的短板，Servlet 只负责业务逻辑而不会通过 out.append() 动态生成 HTML 代码；JSP 中也不会充斥着大量的业务代码。这大大提高了代码的可读性和可维护性。</p>
<h2 id="10-Tomcat-和-Servlet-的联系"><a href="#10-Tomcat-和-Servlet-的联系" class="headerlink" title="10. Tomcat 和 Servlet 的联系"></a>10. Tomcat 和 Servlet 的联系</h2><p>Tomcat 是 Web 应用服务器，是一个 Servlet/JSP 容器。Tomcat 作为 Servlet 容器，负责处理客户请求，把请求传送给 Servlet，并将 Servlet 的响应传送回给客户。而 Servlet 是一种运行在支持 Java 语言的服务器上的组件。Servlet 最常见的用途是扩展 Java Web 服务器功能，提供非常安全的，可移植的，易于使用的 CGI 替代品。</p>
<p><img src="http://qnya.pomo16.club/231.png" alt></p>
<p>① Tomcat 将 HTTP 请求文本接收并解析，然后封装成 HttpServletRequest 类型的 request 对象，所有的 HTTP 头数据读可以通过 request 对象调用对应的方法查询到。</p>
<p>② Tomcat 同时会要响应的信息封装为 HttpServletResponse 类型的 response 对象，通过设置 response 属性就可以控制要输出到浏览器的内容，然后将 response 交给 tomcat，Tomcat 就会将其变成响应文本的格式发送给浏览器。</p>
<p>Java Servlet API 是 Servlet 容器(tomcat) 和 servlet 之间的接口，它定义了 serlvet 的各种方法，还定义了 Servlet 容器传送给 Servlet 的对象类，其中最重要的就是 ServletRequest 和 ServletResponse。所以说我们在编写 servlet 时，需要实现 Servlet 接口，按照其规范进行操作。</p>
<h2 id="11-cookie-和-session"><a href="#11-cookie-和-session" class="headerlink" title="11. cookie 和 session"></a>11. cookie 和 session</h2><h4 id="什么是-cookie？"><a href="#什么是-cookie？" class="headerlink" title="什么是 cookie？"></a>什么是 cookie？</h4><p>Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 Session 的一种方式。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>
<h4 id="什么是-session？"><a href="#什么是-session？" class="headerlink" title="什么是 session？"></a>什么是 session？</h4><p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
<h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><table>
<thead>
<tr>
<th>区别</th>
<th>cookie</th>
<th>session</th>
</tr>
</thead>
<tbody>
<tr>
<td>作用范围</td>
<td>保存在客户端(浏览器)</td>
<td>保存在服务器端</td>
</tr>
<tr>
<td>存取方式</td>
<td>只能保存 ASCII</td>
<td>可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等</td>
</tr>
<tr>
<td>有效期</td>
<td>可设置为长时间保持，比如我们经常使用的默认登录功能</td>
<td>一般失效时间较短，客户端关闭或者 Session 超时都会失效</td>
</tr>
<tr>
<td>隐私策略</td>
<td>存储在客户端，比较容易遭到不法获取</td>
<td>存储在服务端，安全性相对 Cookie 要好一些</td>
</tr>
<tr>
<td>存储大小</td>
<td>单个 Cookie 保存的数据不能超过 4K</td>
<td>可存储数据远高于 Cookie</td>
</tr>
</tbody>
</table>
<h4 id="为什么需要-cookie-和-session，他们有什么关联？"><a href="#为什么需要-cookie-和-session，他们有什么关联？" class="headerlink" title="为什么需要 cookie 和 session，他们有什么关联？"></a>为什么需要 cookie 和 session，他们有什么关联？</h4><p>说起来为什么需要 Cookie ，这就需要从浏览器开始说起，我们都知道浏览器是没有状态的(HTTP 协议无状态)，这意味着浏览器并不知道是张三还是李四在和服务端打交道。这个时候就需要有一个机制来告诉服务端，本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要 Cookie 和 Session 的配合。</p>
<p><img src="http://qnya.pomo16.club/232.png" alt></p>
<p>既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转。</p>
<p>第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 <code>xxx?SessionID=123456...</code>。</p>
<p>第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。</p>
<p>Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。</p>
<p>当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。</p>
<h4 id="如何考虑分布式-Session-问题？"><a href="#如何考虑分布式-Session-问题？" class="headerlink" title="如何考虑分布式 Session 问题？"></a>如何考虑分布式 Session 问题？</h4><p>在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。</p>
<p>分布式 Session 一般会有以下几种解决方案：</p>
<ul>
<li>Nginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。</li>
<li>Session 复制，任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。</li>
<li>共享 Session，服务端无状态话，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致。</li>
</ul>
<h2 id="12-JavaEE-中的三层结构和-MVC"><a href="#12-JavaEE-中的三层结构和-MVC" class="headerlink" title="12. JavaEE 中的三层结构和 MVC"></a>12. JavaEE 中的三层结构和 MVC</h2><p>做企业应用开发时，经常采用三层架构分层：表示层、业务层、持久层。</p>
<p>表示层：负责接收用户请求、转发请求、显示数据等。</p>
<p>业务层：负责组织业务逻辑。</p>
<p>持久层：负责持久化业务对象。</p>
<p>这三个分层，每一层都有不同的模式，就是架构模式。<strong>表示层</strong>最常用的架构模式就是 MVC。</p>
<p>MVC 是<strong>客户端</strong>的一种设计模式，所以他天然就不考虑数据如何存储的问题。作为客户端，只需要解决用户界面、交互和业务逻辑就好了。在 MVC 模式中，View 负责的是用户界面，Controller 负责交互，Model 负责业务逻辑。至于数据如何存储和读取，当然是由 Model 调用服务端的接口来完成。</p>
<p>在三层架构中，并没有客户端/服务端的概念，所以表示层、业务层的任务其实和 MVC 没什么区别，而持久层在 MVC 里面是没有的。</p>
<p><strong>总结：MVC = 表示层 + 业务层，但不包括持久层。</strong></p>
<h2 id="13-RESTful-架构"><a href="#13-RESTful-架构" class="headerlink" title="13. RESTful 架构"></a>13. RESTful 架构</h2><h4 id="什么是REST？"><a href="#什么是REST？" class="headerlink" title="什么是REST？"></a>什么是REST？</h4><p>REST 是所有 Web 应用都应该遵守的架构设计指导原则。 面向资源是 REST 最明显的特征，对于同一个资源的一组不同的操作。对于每个资源只能执行一组有限的操作。（7个HTTP方法：GET/POST/PUT/DELETE/PATCH/HEAD/OPTIONS）</p>
<h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><table>
<thead>
<tr>
<th>HTTP方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>select，从服务器取出资源（一项或多项）。</td>
</tr>
<tr>
<td>POST</td>
<td>create，在服务器新建一个资源。</td>
</tr>
<tr>
<td>PUT</td>
<td>update，在服务器更新资源（客户端提供改变后的完整资源）。</td>
</tr>
<tr>
<td>DELETE</td>
<td>delete，从服务器删除资源。</td>
</tr>
</tbody>
</table>
</div><div class="tags"><a href="/tags/java/">java</a><a href="/tags/jsp/">jsp</a><a href="/tags/Servlet/">Servlet</a></div><div class="post-nav"><a class="pre" href="/2019/06/09/Spring-基础知识/">Spring 基础知识</a><a class="next" href="/2019/06/01/秒杀系统服务器优化思路/">秒杀系统服务器优化思路</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ElasticSearch/">ElasticSearch</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/blog/">blog</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/data/">data</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">19</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/Redis/">Redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/jsp/">jsp</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/jsp/Servlet/">Servlet</a><span class="category-list-count">1</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/projects/">projects</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/web/docker/">docker</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/微信小程序/">微信小程序</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/ElasticSearch/" style="font-size: 15px;">ElasticSearch</a> <a href="/tags/Eclipse/" style="font-size: 15px;">Eclipse</a> <a href="/tags/go/" style="font-size: 15px;">go</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/rpc/" style="font-size: 15px;">rpc</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/jsp/" style="font-size: 15px;">jsp</a> <a href="/tags/JavaWeb/" style="font-size: 15px;">JavaWeb</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/七牛云/" style="font-size: 15px;">七牛云</a> <a href="/tags/CDN/" style="font-size: 15px;">CDN</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a> <a href="/tags/RSS/" style="font-size: 15px;">RSS</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/ftp/" style="font-size: 15px;">ftp</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/projects/" style="font-size: 15px;">projects</a> <a href="/tags/jre/" style="font-size: 15px;">jre</a> <a href="/tags/jdk/" style="font-size: 15px;">jdk</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/tags/Servlet/" style="font-size: 15px;">Servlet</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/hive/" style="font-size: 15px;">hive</a> <a href="/tags/集合/" style="font-size: 15px;">集合</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/操作系统/" style="font-size: 15px;">操作系统</a> <a href="/tags/数组/" style="font-size: 15px;">数组</a> <a href="/tags/String/" style="font-size: 15px;">String</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/07/15/Hive/">Hive</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/15/Hadoop核心组件/">Hadoop核心组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/05/Docker安装ES及IK分词器/">Docker安装ES相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/03/Go-数组和切片/">Go 数组、字符串和切片</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/02/Go-struct-类型Channel/">Go struct{}类型Channel</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/16/Concurrency-in-Go/">Concurrency in Go</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/22/Docker搭建FTP/">Docker搭建FTP</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/Go-Garbage-Collection/">Go Garbage Collection</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/20/git/">git</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/18/ElasticSearch/">ElasticSearch</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/pomo16" title="我的Github" target="_blank">我的Github</a><ul></ul><a href="https://blog.csdn.net/pomo16" title="我的CSDN" target="_blank">我的CSDN</a><ul></ul><a href="http://pomo16.coding.me/" title="我的老博客(荒废已久)" target="_blank">我的老博客(荒废已久)</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Atlantis.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script><!-- 添加点击爱心功能--><script type="text/javascript" src="/js/clicklove.js?v=0.0.0"></script></div></body></html>