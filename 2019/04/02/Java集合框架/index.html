<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java集合框架 | Atlantis</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java集合框架</h1><a id="logo" href="/.">Atlantis</a><p class="description">pomo16的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/toolbox/"><i class="fa fa-book"> 工具箱</i></a><a href="/community/"><i class="fa fa-comments"> 常用社区</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java集合框架</h1><div class="post-meta">Apr 2, 2019<span> | </span><span class="category"><a href="/categories/java/">java</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 8.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 34</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>本文整理自 <a href="https://blog.csdn.net/ns_code" target="_blank" rel="noopener">兰亭风雨</a> 的专栏。</p>
<a id="more"></a>
<h2 id="Java-集合框架"><a href="#Java-集合框架" class="headerlink" title="Java 集合框架"></a>Java 集合框架</h2><p>Java集合框架可以大致分为五个部分：List 列表、Set 列表、Map映射、迭代器(Iterator、Enumeration)、工具类(Arrays、Conllection)。</p>
<p><img src="http://qnya.pomo16.club/152.png" alt></p>
<p>从上图中可以看出，集合类主要分为两大类：Collection 和 Map。</p>
<h2 id="Java-集合框架的组成"><a href="#Java-集合框架的组成" class="headerlink" title="Java 集合框架的组成"></a>Java 集合框架的组成</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h4><p>Collection 是 List、Set 等集合高度抽象出来的接口，它包含了这些集合的基本操作，它主要又分为两大部分：List 和 Set。</p>
<h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><p>List 接口通常表示一个列表（数组、队列、链表、栈等），其中的元素可以重复，常用实现类为 ArrayList 和 LinkedList ，另外还有不常用的 Vector。另外，LinkedList 还是实现了 Queue 接口，因此也可以作为队列使用。</p>
<h4 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h4><p>Set 接口通常表示一个集合，其中的元素不允许重复（通过 hashcode 和 equals 函数保证），常用实现类有 HashSet 和 TreeSet ，HashSet 是通过 Map 中的 HashMap 实现的，而 TreeSet 是通过 Map 中的 TreeMap 实现的。另外，TreeSet 还实现了 SortedSet 接口，因此是有序的集合（集合中的元素要实现 Comparable 接口，并覆写 Compartor 函数才行）。</p>
<h4 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h4><p>Map 是一个映射接口，其中的每个元素都是一个 key-value 键值对，同样抽象类 AbstractMap 通过适配器模式实现了 Map 接口中的大部分函数，TreeMap、HashMap、WeakHashMap 等实现类都通过继承 AbstractMap 来实现，另外，不常用的 HashTable 直接实现了 Map 接口，它和 Vector 都是 JDK1.0 就引入的集合类。</p>
<h4 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h4><p>Iterator 是遍历集合的迭代器（不能遍历 Map，只用来遍历 Collection），Collection 的实现类都实现了 iterator() 函数，它返回一个 Iterator 对象，用来遍历集合，ListIterator 则专门用来遍历 List。而 Enumeration 则是 JDK1.0 时引入的，作用与 Iterator 相同，但它的功能比 Iterator 要少，它只能再 Hashtable、Vector 和 Stack 中使用。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><p>Arrays 和 Collections 是用来操作数组、集合的两个工具类，例如在 ArrayList 和 Vector 中大量调用了 Arrays.Copyof() 方法，而 Collections 中有很多静态方法可以返回各集合类的 synchronized 版本，即线程安全的版本，当然了，如果要用线程安全的结合类，首选 Concurrent 并发包下的对应的集合类。</p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>我们看到，抽象类 AbstractCollection、AbstractList 和 AbstractSet 分别实现了 Collection、List 和 Set 接口，这就是在 Java 集合框架中用的很多的适配器设计模式，用这些抽象类去实现接口，在抽象类中实现接口中的若干或全部方法，这样下面的一些类只需直接继承该抽象类，并实现自己需要的方法即可，而不用实现接口中的全部抽象方法。</p>
<h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p><strong>简介</strong></p>
<ul>
<li>ArrayList 是基于数组实现的，是一个动态数组，其容量能自动增长，类似于 C 语言中的动态申请内存，动态增长内存。</li>
<li>ArrayList 不是线程安全的，只能用在单线程环境下，多线程环境下可以考虑用 Collections.synchronizedList(List l) 函数返回一个线程安全的 ArrayList 类，也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</li>
<li>ArrayList 实现了 Serializable 接口，因此它支持序列化，能够通过序列化传输，实现了 RandomAccess 接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了 Cloneable 接口，能被克隆。</li>
</ul>
<p><strong>源码特征</strong></p>
<ul>
<li><p>ArrayList 有三个构造器</p>
<ul>
<li><strong>无参构造方法构造的 ArrayList 的容量默认为10</strong></li>
<li>带容量大小参数的构造方法</li>
<li>带有 Collection 参数的构造方法，将 Collection 转化为数组赋给 ArrayList 的实现数组 elementData</li>
</ul>
</li>
<li><p>扩充容量的方法 ensureCapacity ：ArrayList在每次增加元素（可能是1个，也可能是一组）时，都要调用该方法来确保足够的容量。当容量不足以容纳当前的元素个数时，就设置新的容量为旧的容量的1.5倍加1，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后用 Arrays.copyof() 方法将元素拷贝到新的数组（详见下面的第3点）。从中可以看出，当容量不够时，每次增加元素，都要将原来的元素拷贝到一个新的数组中，非常之耗时，也因此建议在事先能确定元素数量的情况下，才使用 ArrayList，否则建议使用 LinkedList。</p>
</li>
<li><p>ArrayList 的实现中大量地调用了 Arrays.copyof() 和 System.arraycopy() 方法。 </p>
<ul>
<li>Arrays.copyof() 方法实际上是在其内部又创建了一个长度为 newlength 的数组，调用 System.arraycopy() 方法，将原来数组中的元素复制到了新的数组中。</li>
<li>System.arraycopy() 方法。该方法被标记了 native，调用了系统的 C/C++ 代码，在 JDK 中是看不到的，但在 openJDK 中可以看到其源码。该函数实际上最终调用了 C 语言的 memmove() 函数，因此它可以保证同一个数组内元素的正确复制和移动，比一般的复制方法的实现效率要高很多，很适合用来批量处理数组。Java 强烈推荐在复制大量数组元素时用该方法，以取得更高的效率。</li>
</ul>
</li>
<li><p>注意 ArrayList 的两个转化为静态数组的 toArray 方法。</p>
<ul>
<li><p>Object[] toArray() 方法。该方法有可能会抛出 java.lang.ClassCastException 异常，如果直接用向下转型的方法，将整个 ArrayList 集合转变为指定类型的 Array 数组，便会抛出该异常，而如果转化为 Array 数组时不向下转型，而是将每个元素向下转型，则不会抛出该异常，显然对数组中的元素一个个进行向下转型，效率不高，且不太方便。</p>
</li>
<li><p><code>&lt;T&gt; T[] toArray(T[] a)</code> 方法。该方法可以直接将 ArrayList 转换得到的 Array 进行整体向下转型（转型其实是在该方法的源码中实现的），且从该方法的源码中可以看出，参数 a 的大小不足时，内部会调用 Arrays.copyOf 方法，该方法内部创建一个新的数组返回，因此对该方法的常用形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer[] vectorToArray2(ArrayList&lt;Integer&gt; v) &#123;  </span><br><span class="line">    Integer[] newText = (Integer[])v.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);  </span><br><span class="line">    <span class="keyword">return</span> newText;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>ArrayList 基于数组实现，可以通过下标索引直接查找到指定位置的元素，因此查找效率高，但每次插入或删除元素，就要大量地移动元素，插入删除元素的效率低。</p>
</li>
<li><p>在查找给定元素索引值等的方法中，源码都将该元素的值分为 null 和不为 null 两种情况处理，ArrayList 中允许元素为 null。</p>
</li>
</ul>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p><strong>简介</strong></p>
<ul>
<li>LinkedList 是基于双向循环链表（从源码中可以很容易看出）实现的，除了可以当做链表来操作外，它还可以当做栈、队列和双端队列来使用。</li>
<li>LinkedList 同样是非线程安全的，只在单线程下适合使用。</li>
<li>LinkedList 实现了 Serializable 接口，因此它支持序列化，能够通过序列化传输，实现了 Cloneable 接口，能被克隆。</li>
</ul>
<p><strong>源码特征</strong></p>
<ul>
<li><p>LinkedList 的实现是基于双向循环链表的，且头结点中不存放数据(即使用虚拟头结点)</p>
</li>
<li><p>LinkedList 有两个不同的构造方法。无参构造方法直接建立一个仅包含 head 节点的空链表，包含 Collection 的构造方法，先调用无参构造方法建立一个空链表，而后将 Collection 中的数据加入到链表的尾部后面。</p>
</li>
<li><p>在查找和删除某元素时，源码中都划分为该元素为 null 和不为 null 两种情况来处理，LinkedList 中允许元素为 null。</p>
</li>
<li><p>LinkedList 是基于链表实现的，因此不存在容量不足的问题，所以这里没有扩容的方法。</p>
</li>
<li><p>注意源码中的 <code>Entry&lt;E&gt; entry(int index)</code> 方法。该方法返回双向链表中指定位置处的节点，而链表中是没有下标索引的，要指定位置出的元素，就要遍历该链表，从源码的实现中，我们看到这里有一个加速动作。源码中先将 index 与长度 size 的一半比较，如果 index&lt;size/2 ，就只从位置 0 往后遍历到位置 index 处，而如果 index&gt;size/2，就只从位置 size 往前遍历到位置 index 处。这样可以减少一部分不必要的遍历，从而提高一定的效率（实际上效率还是很低）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取双向链表中指定位置的节点  </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry&lt;E&gt; <span class="title">entry</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span> + index + <span class="string">", Size: "</span>+size);  </span><br><span class="line">    Entry&lt;E&gt; e = header;  </span><br><span class="line">    <span class="comment">// 获取index处的节点。  </span></span><br><span class="line">    <span class="comment">// 若index &lt; 双向链表长度的1/2,则从前先后查找;  </span></span><br><span class="line">    <span class="comment">// 否则，从后向前查找。  </span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= index; i++)  </span><br><span class="line">            e = e.next;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &gt; index; i--)  </span><br><span class="line">            e = e.previous;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> e;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意链表类对应的数据结构 Entry。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向链表的节点所对应的数据结构。  </span></span><br><span class="line"><span class="comment">// 包含3部分：上一节点，下一节点，当前节点值。  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">E</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="comment">// 当前节点所包含的值  </span></span><br><span class="line">    E element;  </span><br><span class="line">    <span class="comment">// 下一个节点  </span></span><br><span class="line">    Entry&lt;E&gt; next;  </span><br><span class="line">    <span class="comment">// 上一个节点  </span></span><br><span class="line">    Entry&lt;E&gt; previous;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 链表节点的构造函数。  </span></span><br><span class="line"><span class="comment">     * 参数说明：  </span></span><br><span class="line"><span class="comment">     *   element  —— 节点所包含的数据  </span></span><br><span class="line"><span class="comment">     *   next      —— 下一个节点  </span></span><br><span class="line"><span class="comment">     *   previous —— 上一个节点  </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.element = element;  </span><br><span class="line">        <span class="keyword">this</span>.next = next;  </span><br><span class="line">        <span class="keyword">this</span>.previous = previous;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>LinkedList 是基于链表实现的，因此插入删除效率高，查找效率低（虽然有一个加速动作）。</p>
</li>
<li><p>要注意源码中还实现了栈和队列的操作方法，因此也可以作为栈、队列和双端队列来使用。</p>
</li>
</ul>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p><strong>简介</strong></p>
<ul>
<li>Vector 也是基于数组实现的，是一个动态数组，其容量能自动增长。</li>
<li>Vector 是 JDK1.0 引入了，它的很多实现方法都加入了同步语句，因此是线程安全的（其实也只是相对安全，有些时候还是要加入同步语句来保证线程的安全），可以用于多线程环境。</li>
<li>Vector 实现了 Serializable 接口，因此它支持序列化，实现了 Cloneable 接口，能被克隆，实现了 RandomAccess 接口，支持快速随机访问。</li>
</ul>
<p><strong>源码特征</strong></p>
<ul>
<li>Vector 有四个不同的构造方法<ul>
<li>无参构造方法的容量为默认值10</li>
<li>仅包含容量的构造方法则将容量增长量（从源码中可以看出容量增长量的作用，第二点也会对容量增长量详细说）明置为0。</li>
<li>指定 Vector “容量大小”和”增长系数”的构造函数。</li>
<li>指定集合的 Vector 构造函数。</li>
</ul>
</li>
<li><p>注意扩充容量的方法 ensureCapacityHelper：与 ArrayList 相同，Vector 在每次增加元素（可能是1个，也可能是一组）时，都要调用该方法来确保足够的容量。当容量不足以容纳当前的元素个数时，就先看构造方法中传入的容量增长量参数 CapacityIncrement 是否为0，如果不为0，就设置新的容量为就容量加上容量增长量，如果为0，就设置新的容量为旧的容量的2倍，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后同样用 Arrays.copyof() 方法将元素拷贝到新的数组。</p>
</li>
<li><p>很多方法都加入了 synchronized 同步语句，来保证线程安全。</p>
</li>
<li>同样在查找给定元素索引值等的方法中，源码都将该元素的值分为 null 和不为 null 两种情况处理，Vector 中也允许元素为 null。</li>
<li>其他很多地方都与 ArrayList 实现大同小异，Vector 现在已经基本不再使用。 </li>
</ul>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p><strong>简介</strong></p>
<ul>
<li>HashMap 是基于哈希表实现的，每一个元素是一个 key-value 对，其内部通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。</li>
<li>HashMap 是非线程安全的，只是用于单线程环境下，多线程环境下可以采用 concurrent 并发包下的 concurrentHashMap。</li>
<li>HashMap 实现了 Serializable 接口，因此它支持序列化，实现了 Cloneable 接口，能被克隆。</li>
</ul>
<p><strong>源码特征</strong></p>
<ul>
<li><p>首先要清楚HashMap的存储结构，如下图所示：</p>
<p><img src="http://qnya.pomo16.club/153.png" alt></p>
<p>图中，紫色部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。</p>
</li>
<li><p>首先看链表中节点的数据结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Entry是单向链表。  </span></span><br><span class="line"><span class="comment">// 它是 “HashMap链式存储法”对应的链表。  </span></span><br><span class="line"><span class="comment">// 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数  </span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> K key;  </span><br><span class="line">    V value;  </span><br><span class="line">    <span class="comment">// 指向下一个节点  </span></span><br><span class="line">    Entry&lt;K,V&gt; next;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 构造函数。  </span></span><br><span class="line">    <span class="comment">// 输入参数包括"哈希值(h)", "键(k)", "值(v)", "下一节点(n)"  </span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;  </span><br><span class="line">        value = v;  </span><br><span class="line">        next = n;  </span><br><span class="line">        key = k;  </span><br><span class="line">        hash = h;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> key;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;  </span><br><span class="line">        V oldValue = value;  </span><br><span class="line">        value = newValue;  </span><br><span class="line">        <span class="keyword">return</span> oldValue;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 判断两个Entry是否相等  </span></span><br><span class="line">    <span class="comment">// 若两个Entry的“key”和“value”都相等，则返回true。  </span></span><br><span class="line">    <span class="comment">// 否则，返回false  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        Map.Entry e = (Map.Entry)o;  </span><br><span class="line">        Object k1 = getKey();  </span><br><span class="line">        Object k2 = e.getKey();  </span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;  </span><br><span class="line">            Object v1 = getValue();  </span><br><span class="line">            Object v2 = e.getValue();  </span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 实现hashCode()  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> (key==<span class="keyword">null</span>   ? <span class="number">0</span> : key.hashCode()) ^  </span><br><span class="line">               (value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 当向HashMap中添加元素时，绘调用recordAccess()。  </span></span><br><span class="line">    <span class="comment">// 这里不做任何处理  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 当从HashMap中删除元素时，绘调用recordRemoval()。  </span></span><br><span class="line">    <span class="comment">// 这里不做任何处理  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的结构元素除了 key、value、hash 外，还有 next ，next 指向下一个节点。另外，这里覆写了 equals 和 hashCode 方法来保证键值对的独一无二。</p>
</li>
<li><p>HashMap共有四个构造方法。构造方法中提到了两个很重要的参数：初始容量和加载因子。这两个参数是影响 HashMap 性能的重要参数。</p>
<ul>
<li>容量表示哈希表中槽的数量（即哈希数组的长度），初始容量是创建哈希表时的容量（从构造函数中可以看出，如果不指明，则默认为16）。<ul>
<li>无论我们指定的容量为多少，构造方法都会将实际容量设为不小于指定容量的2的次方的一个数，且最大值不能超过2的30次方。</li>
</ul>
</li>
<li>加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 resize 操作（即扩容）。<ul>
<li>如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长）；如果加载因子太小，那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了），对空间造成严重浪费。如果我们在构造方法中不指定，则系统默认加载因子为0.75，这是一个比较理想的值，一般情况下我们是无需修改的。</li>
</ul>
</li>
</ul>
</li>
<li><p>HashMap 中 key 和 value 都允许为 null。</p>
</li>
<li><p>要重点分析下 HashMap 中用的最多的两个方法 put 和 get。先从比较简单的 get 方法着手，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 获取key对应的value  </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </span><br><span class="line">          <span class="keyword">return</span> getForNullKey();  </span><br><span class="line">      <span class="comment">// 获取key的hash值  </span></span><br><span class="line">      <span class="keyword">int</span> hash = hash(key.hashCode());  </span><br><span class="line">      <span class="comment">// 在“该hash值对应的链表”上查找“键值等于key”的元素  </span></span><br><span class="line">      <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];  </span><br><span class="line">           e != <span class="keyword">null</span>;  </span><br><span class="line">           e = e.next) &#123;  </span><br><span class="line">          Object k;  </span><br><span class="line">	<span class="comment">//判断key是否相同</span></span><br><span class="line">          <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))  </span><br><span class="line">              <span class="keyword">return</span> e.value;  </span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//没找到则返回null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 获取“key为null”的元素的值  </span></span><br><span class="line">  <span class="comment">// HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！  </span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;  </span><br><span class="line">          <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)  </span><br><span class="line">              <span class="keyword">return</span> e.value;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>首先，如果 key 为 null，则直接从哈希表的第一个位置 table[0] 对应的链表上查找。<strong>记住，key 为 null 的键值对永远都放在以 table[0] 为头结点的链表中，当然不一定是存放在头结点 table[0] 中</strong>。</p>
</li>
<li><p>如果 key 不为 null，则先求的 key 的 hash 值，根据 hash 值找到在 table 中的索引，在该索引对应的单链表中查找是否有键值对的 key 与目标 key 相等，有就返回对应的 value，没有则返回 null。</p>
</li>
</ul>
<p>put方法稍微复杂些，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 将“key-value”添加到HashMap中  </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;  </span><br><span class="line">      <span class="comment">// 若“key为null”，则将该键值对添加到table[0]中。  </span></span><br><span class="line">      <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </span><br><span class="line">          <span class="keyword">return</span> putForNullKey(value);  </span><br><span class="line">      <span class="comment">// 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。  </span></span><br><span class="line">      <span class="keyword">int</span> hash = hash(key.hashCode());  </span><br><span class="line">      <span class="keyword">int</span> i = indexFor(hash, table.length);  </span><br><span class="line">      <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;  </span><br><span class="line">          Object k;  </span><br><span class="line">          <span class="comment">// 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！  </span></span><br><span class="line">          <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class="line">              V oldValue = e.value;  </span><br><span class="line">              e.value = value;  </span><br><span class="line">              e.recordAccess(<span class="keyword">this</span>);  </span><br><span class="line">              <span class="keyword">return</span> oldValue;  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">   </span><br><span class="line">      <span class="comment">// 若“该key”对应的键值对不存在，则将“key-value”添加到table中  </span></span><br><span class="line">      modCount++;</span><br><span class="line"><span class="comment">//将key-value添加到table[i]处</span></span><br><span class="line">      addEntry(hash, key, value, i);  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果key为null，则将其添加到table[0]对应的链表中，putForNullKey的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// putForNullKey()的作用是将“key为null”键值对添加到table[0]位置  </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            V oldValue = e.value;  </span><br><span class="line">            e.value = value;  </span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);  </span><br><span class="line">            <span class="keyword">return</span> oldValue;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 如果没有存在key为null的键值对，则直接题阿见到table[0]处!  </span></span><br><span class="line">    modCount++;  </span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 key 不为 null，则同样先求出 key 的 hash 值，根据 hash 值得出在 table 中的索引，而后遍历对应的单链表，如果单链表中存在与目标 key 相等的键值对，则将新的 value 覆盖旧的 value，比将旧的 value 返回，<strong>如果找不到与目标 key 相等的键值对，或者该单链表为空，则将该键值对插入到改单链表的头结点位置（每次新插入的节点都是放在头结点的位置）</strong>，该操作是有 addEntry 方法实现的，它的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 保存“bucketIndex”位置的值到“e”中  </span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];  </span><br><span class="line">    <span class="comment">// 设置“bucketIndex”位置的元素为“新Entry”，  </span></span><br><span class="line">    <span class="comment">// 设置“e”为“新Entry的下一个节点”  </span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);  </span><br><span class="line">    <span class="comment">// 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小  </span></span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)  </span><br><span class="line">        resize(<span class="number">2</span> * table.length);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里倒数第三行的构造方法，将 key-value 键值对赋给 table[bucketIndex]，并将其 next 指向元素 e，这便将 key-value 放到了头结点中，并将之前的头结点接在了它的后面。<strong>该方法也说明，每次 put 键值对的时候，总是将新的该键值对放在 table[bucketIndex] 处（即头结点处）。</strong></p>
<p><strong>另外注意最后两行代码，每次加入键值对时，都要判断当前已用的槽的数目是否大于等于阀值（容量*加载因子），如果大于等于，则进行扩容，将容量扩为原来容量的2倍。</strong></p>
</li>
<li><p>扩容 resize 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重新调整HashMap的大小，newCapacity是调整后的单位  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;  </span><br><span class="line">    Entry[] oldTable = table;  </span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;  </span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  </span><br><span class="line">        threshold = Integer.MAX_VALUE;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中，  </span></span><br><span class="line">    <span class="comment">// 然后，将“新HashMap”赋值给“旧HashMap”。  </span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  </span><br><span class="line">    transfer(newTable);  </span><br><span class="line">    table = newTable;  </span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    很明显，是新建了一个 HashMap 的底层数组，而后调用 transfer 方法，将就 HashMap 的全部元素添加到新的 HashMap 中（要重新计算元素在新的数组中的索引位置）。transfer 方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将HashMap中的全部元素都添加到newTable中  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;  </span><br><span class="line">    Entry[] src = table;  </span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;  </span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];  </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            src[j] = <span class="keyword">null</span>;  </span><br><span class="line">            <span class="keyword">do</span> &#123;  </span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;  </span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);  </span><br><span class="line">                e.next = newTable[i];  </span><br><span class="line">                newTable[i] = e;  </span><br><span class="line">                e = next;  </span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>很明显，扩容是一个相当耗时的操作，因为它需要重新计算这些元素在新的数组中的位置并进行复制处理。因此，我们在用 HashMap 的时，最好能提前预估下 HashMap 中元素的个数，这样有助于提高 HashMap 的性能。</strong></p>
</li>
<li><p>注意 containsKey 方法和 containsValue 方法。前者直接可以通过 key 的哈希值将搜索范围定位到指定索引对应的链表，而后者要对哈希数组的每个链表进行搜索。</p>
</li>
<li><p>我们重点来分析下求 hash 值和索引值的方法，这两个方法便是 HashMap 设计的最为核心的部分，二者结合能保证哈希表中的元素尽可能均匀地散列。</p>
<ul>
<li><p>计算哈希值的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>它只是一个数学公式，JDK 这样设计对 hash 值的计算，自然有它的好处，至于为什么这样设计，我们这里不去追究，只要明白一点，用的位的操作使 hash 值的计算效率很高。</p>
</li>
<li><p>由 hash 值找到对应索引的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个我们要重点说下，我们一般对哈希表的散列很自然地会想到用 hash 值对 length 取模（即除法散列法），Hashtable 中也是这样实现的，这种方法基本能保证元素在哈希表中散列的比较均匀，但取模会用到除法运算，效率很低，<strong>HashMap 中则通过 h&amp;(length-1) 的方法来代替取模，同样实现了均匀的散列，但效率要高很多，这也是 HashMap 对 Hashtable 的一个改进。</strong></p>
</li>
</ul>
</li>
<li><p>为什么哈希表的容量一定要是2的整数次幂?</p>
<ul>
<li><strong>length 为2的整数次幂的话，h&amp;(length-1) 就相当于对 length 取模，这样便保证了散列的均匀，同时也提升了效率</strong></li>
<li>length 为2的整数次幂的话，为偶数，这样 length-1 为奇数，奇数的最后一位是1，这样便保证了 h&amp;(length-1) 的最后一位可能为0，也可能为1（这取决于 h 的值），即与后的结果可能为偶数，也可能为奇数，这样便可以保证散列的均匀性，而如果 length 为奇数的话，很明显 length-1 为偶数，它的最后一位是0，这样 h&amp;(length-1) 的最后一位肯定为0，即只能为偶数，这样任何 hash 值都只会被散列到数组的偶数下标位置上，这便浪费了近一半的空间</li>
<li><strong>因此，length 取2的整数次幂，是为了使不同 hash 值发生碰撞的概率较小，这样就能使元素在哈希表中均匀地散列。</strong></li>
</ul>
</li>
</ul>
<h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p><strong>简介</strong></p>
<ul>
<li>Hashtable 同样是基于哈希表实现的，同样每个元素是一个 key-value 对，其内部也是通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。</li>
<li>Hashtable 也是  JDK1.0 引入的类，是线程安全的，能用于多线程环境中。</li>
<li>Hashtable 同样实现了 Serializable 接口，它支持序列化，实现了 Cloneable 接口，能被克隆。</li>
</ul>
<p><strong>源码特征</strong></p>
<p>针对 Hashtable，我们同样给出几点比较重要的总结，但要结合与 HashMap 的比较来总结。</p>
<ul>
<li><p>二者的存储结构和解决冲突的方法都是相同的。</p>
</li>
<li><p>HashTable 在不指定容量的情况下的默认容量为11，而 HashMap 为16，Hashtable 不要求底层数组的容量一定要为2的整数次幂，而 HashMap 则要求一定为2的整数次幂。</p>
</li>
<li><p><strong>Hashtable 中 key 和 value 都不允许为 null，而 HashMap 中 key 和 value 都允许为 null（key 只能有一个为 null，而 value 则可以有多个为 null）。但是如果在 Hashtable 中有类似 put(null,null) 的操作，编译同样可以通过，因为 key 和 value 都是 Object 类型，但运行时会抛出 NullPointerException 异常，这是 JDK 的规范规定的。</strong>我们来看下 ContainsKey 方法和 ContainsValue 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 判断Hashtable是否包含“值(value)”  </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span> </span>&#123;  </span><br><span class="line">      <span class="comment">//注意，Hashtable中的value不能是null，  </span></span><br><span class="line">      <span class="comment">// 若是null的话，抛出异常!  </span></span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;  </span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">      &#125;  </span><br><span class="line">   </span><br><span class="line">      <span class="comment">// 从后向前遍历table数组中的元素(Entry)  </span></span><br><span class="line">      <span class="comment">// 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value  </span></span><br><span class="line">      Entry tab[] = table;  </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = tab.length ; i-- &gt; <span class="number">0</span> ;) &#123;  </span><br><span class="line">          <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next) &#123;  </span><br><span class="line">              <span class="keyword">if</span> (e.value.equals(value)) &#123;  </span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">              &#125;  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">return</span> contains(value);  </span><br><span class="line">  &#125;  </span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 判断Hashtable是否包含key  </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;  </span><br><span class="line">      Entry tab[] = table;  </span><br><span class="line"><span class="comment">//计算hash值，直接用key的hashCode代替</span></span><br><span class="line">      <span class="keyword">int</span> hash = key.hashCode();    </span><br><span class="line">      <span class="comment">// 计算在数组中的索引值 </span></span><br><span class="line">      <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;  </span><br><span class="line">      <span class="comment">// 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素  </span></span><br><span class="line">      <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;  </span><br><span class="line">          <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;  </span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>很明显，如果 value 为 null，会直接抛出 NullPointerException 异常，但源码中并没有对 key 是否为 null 判断，有点小不解！不过 NullPointerException 属于 RuntimeException 异常，是可以由 JVM 自动抛出的，也许对 key 的值在 JVM 中有所限制吧。</strong></p>
</li>
<li><p>Hashtable 扩容时，将容量变为原来的2倍加1，而 HashMap 扩容时，将容量变为原来的2倍。</p>
</li>
<li><p><strong>Hashtable 计算 hash 值，直接用 key 的 hashCode()，而 HashMap 重新计算了 key 的 hash 值，Hashtable 在求 hash 值对应的位置索引时，用取模运算，而 HashMap 在求位置索引时，则用与运算，且这里一般先用hash&amp;0x7FFFFFFF 后，再对 length 取模，&amp;0x7FFFFFFF 的目的是为了将负的hash值转化为正值，因为 hash值有可能为负数，而 &amp;0x7FFFFFFF 后，只有符号外改变，而后面的位都不变。</strong> </p>
</li>
</ul>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p><strong>简介</strong></p>
<ul>
<li>TreeMap是基于红黑树实现的，这里只对红黑树做个简单的介绍，红黑树是一种特殊的二叉排序树，红黑树通过一些限制，使其不会出现二叉树排序树中极端的一边倒的情况，相对二叉排序树而言，这自然提高了查询的效率。</li>
</ul>
<p><strong>源码特征</strong></p>
<ul>
<li><p>存储结构：TreeMap的排序是基于对key的排序实现的，它的每一个Entry代表红黑树的一个节点，Entry的数据结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">      <span class="comment">// 键  </span></span><br><span class="line">      K key;  </span><br><span class="line">      <span class="comment">// 值  </span></span><br><span class="line">      V value;  </span><br><span class="line">      <span class="comment">// 左孩子  </span></span><br><span class="line">      Entry&lt;K,V&gt; left = <span class="keyword">null</span>;  </span><br><span class="line">      <span class="comment">// 右孩子  </span></span><br><span class="line">      Entry&lt;K,V&gt; right = <span class="keyword">null</span>;  </span><br><span class="line">      <span class="comment">// 父节点  </span></span><br><span class="line">      Entry&lt;K,V&gt; parent;  </span><br><span class="line">      <span class="comment">// 当前节点颜色  </span></span><br><span class="line">      <span class="keyword">boolean</span> color = BLACK;  </span><br><span class="line">   </span><br><span class="line">      <span class="comment">// 构造函数  </span></span><br><span class="line">      Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;  </span><br><span class="line">          <span class="keyword">this</span>.key = key;  </span><br><span class="line">          <span class="keyword">this</span>.value = value;  </span><br><span class="line">          <span class="keyword">this</span>.parent = parent;  </span><br><span class="line">      &#125;  </span><br><span class="line">   </span><br><span class="line">。。。。。。</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>TreeMap一共有4个构造方法：</p>
<ul>
<li><p>无参构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    comparator = <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用无参构造方法，不指定比较器，这时候，排序的实现要依赖 key.compareTo() 方法，因此 key 必须实现 Comparable 接口，并覆写其中的 compareTo 方法。</p>
</li>
<li><p>带有比较器的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用带比较器的构造方法，这时候，排序依赖该比较器，key 可以不用实现 Comparable 接口。</p>
</li>
<li><p>带 Map 的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;  </span><br><span class="line">    comparator = <span class="keyword">null</span>;  </span><br><span class="line">    putAll(m);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该构造方法同样不指定比较器，调用 putAll 方法将 Map 中的所有元素加入到 TreeMap 中。putAll 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将map中的全部节点添加到TreeMap中  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; map)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 获取map的大小  </span></span><br><span class="line">    <span class="keyword">int</span> mapSize = map.size();  </span><br><span class="line">    <span class="comment">// 如果TreeMap的大小是0,且map的大小不是0,且map是已排序的“key-value对”  </span></span><br><span class="line">    <span class="keyword">if</span> (size==<span class="number">0</span> &amp;&amp; mapSize!=<span class="number">0</span> &amp;&amp; map <span class="keyword">instanceof</span> SortedMap) &#123;  </span><br><span class="line">        Comparator c = ((SortedMap)map).comparator();  </span><br><span class="line">        <span class="comment">// 如果TreeMap和map的比较器相等；  </span></span><br><span class="line">        <span class="comment">// 则将map的元素全部拷贝到TreeMap中，然后返回！  </span></span><br><span class="line">        <span class="keyword">if</span> (c == comparator || (c != <span class="keyword">null</span> &amp;&amp; c.equals(comparator))) &#123;  </span><br><span class="line">            ++modCount;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                buildFromSorted(mapSize, map.entrySet().iterator(),  </span><br><span class="line">                            <span class="keyword">null</span>, <span class="keyword">null</span>);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 调用AbstractMap中的putAll();  </span></span><br><span class="line">    <span class="comment">// AbstractMap中的putAll()又会调用到TreeMap的put()  </span></span><br><span class="line">    <span class="keyword">super</span>.putAll(map);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，如果 Map 里的元素是排好序的，就调用 buildFromSorted 方法来拷贝 Map 中的元素，这在下一个构造方法中会重点提及，而如果 Map 中的元素不是排好序的，就调用 AbstractMap 的 putAll(map) 方法，该方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())  </span><br><span class="line">        put(e.getKey(), e.getValue());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显它是将 Map 中的元素一个个 put（插入）到 TreeMap 中的，主要因为 Map 中的元素是无序存放的，因此要一个个插入到红黑树中，使其有序存放，并满足红黑树的性质。</p>
</li>
<li><p>带有 SortedMap 的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;  </span><br><span class="line">    comparator = m.comparator();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将比较器指定为 m 的比较器，这取决于生成 m 时调用构造方法是否传入了指定的构造器，而后调用 buildFromSorted 方法，将 SortedMap 中的元素插入到 TreeMap 中，由于 SortedMap 中的元素师有序的，实际上它是根据 SortedMap 创建的 TreeMap，将 SortedMap 中对应的元素添加到 TreeMap 中。</p>
</li>
</ul>
</li>
<li><p>插入删除</p>
<ul>
<li><p>插入 put</p>
<p>插入操作即对应 TreeMap 的 put 方法，put 操作实际上只需按照二叉排序树的插入步骤来操作即可，插入到指定位置后，再做调整，使其保持红黑树的特性。put 源码的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;  </span><br><span class="line">    Entry&lt;K,V&gt; t = root;  </span><br><span class="line">    <span class="comment">// 若红黑树为空，则插入根节点  </span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;  </span><br><span class="line">    <span class="comment">// TBD:  </span></span><br><span class="line">    <span class="comment">// 5045147: (coll) Adding null to an empty TreeSet should  </span></span><br><span class="line">    <span class="comment">// throw NullPointerException  </span></span><br><span class="line">    <span class="comment">//  </span></span><br><span class="line">    <span class="comment">// compare(key, key); // type check  </span></span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;K,V&gt;(key, value, <span class="keyword">null</span>);  </span><br><span class="line">        size = <span class="number">1</span>;  </span><br><span class="line">        modCount++;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span> cmp;  </span><br><span class="line">    Entry&lt;K,V&gt; parent;  </span><br><span class="line">    <span class="comment">// split comparator and comparable paths  </span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;  </span><br><span class="line">    <span class="comment">// 找出(key, value)在二叉排序树中的插入位置。  </span></span><br><span class="line">    <span class="comment">// 红黑树是以key来进行排序的，所以这里以key来进行查找。  </span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">do</span> &#123;  </span><br><span class="line">            parent = t;  </span><br><span class="line">            cmp = cpr.compare(key, t.key);  </span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)  </span><br><span class="line">                t = t.left;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)  </span><br><span class="line">                t = t.right;  </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);  </span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;  </span><br><span class="line">        <span class="keyword">do</span> &#123;  </span><br><span class="line">            parent = t;  </span><br><span class="line">            cmp = k.compareTo(t.key);  </span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)  </span><br><span class="line">                t = t.left;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)  </span><br><span class="line">                t = t.right;  </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);  </span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 为（key-value）新建节点  </span></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;K,V&gt;(key, value, parent);  </span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)  </span><br><span class="line">        parent.left = e;  </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        parent.right = e;  </span><br><span class="line">    <span class="comment">// 插入新的节点后，调用fixAfterInsertion调整红黑树。  </span></span><br><span class="line">    fixAfterInsertion(e);  </span><br><span class="line">    size++;  </span><br><span class="line">    modCount++;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除 deleteEntry</p>
<p>删除操作及对应 TreeMap 的 deleteEntry 方法，deleteEntry 方法同样也只需按照二叉排序树的操作步骤实现即可，删除指定节点后，再对树进行调整即可。deleteEntry 方法的实现源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除“红黑树的节点p”  </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;  </span><br><span class="line">    modCount++;  </span><br><span class="line">    size--;  </span><br><span class="line">    		</span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        Entry&lt;K,V&gt; s = successor (p);  </span><br><span class="line">        p.key = s.key;  </span><br><span class="line">        p.value = s.value;  </span><br><span class="line">        p = s;  </span><br><span class="line">    &#125; </span><br><span class="line">      </span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);  </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        replacement.parent = p.parent;  </span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)  </span><br><span class="line">            root = replacement;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)  </span><br><span class="line">            p.parent.left  = replacement;  </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            p.parent.right = replacement;  </span><br><span class="line">     </span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;  </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)  </span><br><span class="line">            fixAfterDeletion(replacement);  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123; </span><br><span class="line">        root = <span class="keyword">null</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)  </span><br><span class="line">            fixAfterDeletion(p);  </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)  </span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)  </span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;  </span><br><span class="line">            p.parent = <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="TreeMap-和-HashMap-的比较"><a href="#TreeMap-和-HashMap-的比较" class="headerlink" title="TreeMap 和 HashMap 的比较"></a>TreeMap 和 HashMap 的比较</h4><ul>
<li><p>TreeMap 是根据 key 进行排序的，它的排序和定位需要依赖比较器或覆写 Comparable 接口，也因此不需要 key 覆写 hashCode 方法和 equals 方法，就可以排除掉重复的 key，而 HashMap 的 key 则需要通过覆写 hashCode 方法和 equals 方法来确保没有重复的 key。</p>
</li>
<li><p>TreeMap 的查询、插入、删除效率均没有 HashMap 高，一般只有要对 key 排序时才使用 TreeMap。</p>
</li>
<li><p>TreeMap 的 key 不能为 null，而 HashMap 的 key 可以为 null。</p>
</li>
<li>注：对 TreeSet 和 HashSet 的源码不再进行剖析，二者分别是基于 TreeMap 和 HashMap 实现的，只是对应的节点中只有 key，而没有 value，因此对 TreeMap 和 HashMap 比较了解的话，对 TreeSet 和 HashSet 的理解就会非常容易。</li>
</ul>
</div><div class="tags"><a href="/tags/java/">java</a><a href="/tags/集合/">集合</a></div><div class="post-nav"><a class="pre" href="/2019/04/02/Java网络通信/">Java网络通信</a><a class="next" href="/2019/03/25/Java的Object类/">Java的Object类</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ElasticSearch/">ElasticSearch</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/blog/">blog</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/data/">data</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">19</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/Redis/">Redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/jsp/">jsp</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/jsp/Servlet/">Servlet</a><span class="category-list-count">1</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/projects/">projects</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/web/docker/">docker</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/微信小程序/">微信小程序</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/ElasticSearch/" style="font-size: 15px;">ElasticSearch</a> <a href="/tags/Eclipse/" style="font-size: 15px;">Eclipse</a> <a href="/tags/go/" style="font-size: 15px;">go</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/rpc/" style="font-size: 15px;">rpc</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/jsp/" style="font-size: 15px;">jsp</a> <a href="/tags/JavaWeb/" style="font-size: 15px;">JavaWeb</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/七牛云/" style="font-size: 15px;">七牛云</a> <a href="/tags/CDN/" style="font-size: 15px;">CDN</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a> <a href="/tags/RSS/" style="font-size: 15px;">RSS</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/ftp/" style="font-size: 15px;">ftp</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/projects/" style="font-size: 15px;">projects</a> <a href="/tags/jre/" style="font-size: 15px;">jre</a> <a href="/tags/jdk/" style="font-size: 15px;">jdk</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/tags/Servlet/" style="font-size: 15px;">Servlet</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/hive/" style="font-size: 15px;">hive</a> <a href="/tags/集合/" style="font-size: 15px;">集合</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/操作系统/" style="font-size: 15px;">操作系统</a> <a href="/tags/数组/" style="font-size: 15px;">数组</a> <a href="/tags/String/" style="font-size: 15px;">String</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/07/15/Hive/">Hive</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/15/Hadoop核心组件/">Hadoop核心组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/05/Docker安装ES及IK分词器/">Docker安装ES相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/03/Go-数组和切片/">Go 数组、字符串和切片</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/02/Go-struct-类型Channel/">Go struct{}类型Channel</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/16/Concurrency-in-Go/">Concurrency in Go</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/22/Docker搭建FTP/">Docker搭建FTP</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/Go-Garbage-Collection/">Go Garbage Collection</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/20/git/">git</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/18/ElasticSearch/">ElasticSearch</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/pomo16" title="我的Github" target="_blank">我的Github</a><ul></ul><a href="https://blog.csdn.net/pomo16" title="我的CSDN" target="_blank">我的CSDN</a><ul></ul><a href="http://pomo16.coding.me/" title="我的老博客(荒废已久)" target="_blank">我的老博客(荒废已久)</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Atlantis.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script><!-- 添加点击爱心功能--><script type="text/javascript" src="/js/clicklove.js?v=0.0.0"></script></div></body></html>